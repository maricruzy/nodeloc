// ==UserScript==
// @name         æ™ºèƒ½è®ºå›åŠ©æ‰‹ Pro
// @namespace    http://tampermonkey.net/
// @version      2.6.0
// @description  NodeLocæ™ºèƒ½è®ºå›åŠ©æ‰‹ - è‡ªåŠ¨é˜…è¯»/ç‚¹èµ/å›å¤ï¼Œå‡çº§è¿›åº¦è¿½è¸ªï¼Œå¼¹çª—æ£€æµ‹ï¼Œé™åˆ¶ç›‘æ§ï¼Œæ•°æ®ç»Ÿè®¡ï¼Œä½ç½®è®°å¿†ç­‰å…¨æ–¹ä½åŠŸèƒ½
// @author       Enhanced by AI
// @match        https://meta.discourse.org/*
// @match        https://meta.appinn.net/*
// @match        https://community.openai.com/*
// @match        https://www.nodeloc.com/*
// @match        https://bbs.tampermonkey.net.cn/*
// @match        https://greasyfork.org/*
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_deleteValue
// @grant        GM_listValues
// @grant        GM_notification
// @grant        GM_openInTab
// @grant        GM_xmlhttpRequest
// @grant        unsafeWindow
// @license      MIT
// @icon         https://www.google.com/s2/favicons?domain=discourse.org
// @downloadURL  https://update.greasyfork.org/scripts/enhanced-forum-assistant/Enhanced%20Forum%20Assistant.user.js
// @updateURL    https://update.greasyfork.org/scripts/enhanced-forum-assistant/Enhanced%20Forum%20Assistant.meta.js
// ==/UserScript==

(function () {
  "use strict";

  // ===== é…ç½®ç®¡ç†ç±» =====
  class ConfigManager {
    constructor() {
      this.defaultConfig = {
        // åŸºç¡€é…ç½®
        possibleBaseURLs: [
          "https://linux.do",
          "https://meta.discourse.org",
          "https://meta.appinn.net",
          "https://community.openai.com",
          "https://www.nodeloc.com",
          "https://bbs.tampermonkey.net.cn",
          "https://greasyfork.org"
        ],

        // è¡Œä¸ºå‚æ•°
        commentLimit: 1000,
        topicListLimit: 100,
        likeLimit: 55,
        stuckTimeout: 15000,
        minScrollDelta: 50,
        maxIdleTime: 60000,
        maxLogEntries: 200,
        minTopicChangeDelay: 3000,
        maxTopicChangeDelay: 8000,
        minReadTimeLower: 45000,
        minReadTimeUpper: 120000,
        fetchRetryDelay: 30000,

        // æ»šåŠ¨å‚æ•°
        scrollSegmentDistanceMin: 300,
        scrollSegmentDistanceMax: 1000,
        scrollSegmentDurationMin: 2000,
        scrollSegmentDurationMax: 6000,
        randomPauseProbability: 0.2,
        randomPauseDurationMin: 100,
        randomPauseDurationMax: 800,

        // è´å¡å°”æ›²çº¿å‚æ•°
        bezierP1Min: 0.1,
        bezierP1Max: 0.4,
        bezierP2Min: 0.6,
        bezierP2Max: 0.9,

        // æ–°å¢åŠŸèƒ½é…ç½®
        enableMouseSimulation: true,
        enableAdvancedBehavior: true,
        enableDataAnalysis: true,
        enableSafetyFeatures: true,
        autoReplyEnabled: false,
        keywordMonitoring: false,
        proxyEnabled: false,

        // UIé…ç½®
        theme: 'dark',
        language: 'zh-CN',
        showStatistics: true,
        compactMode: false
      };

      this.config = this.loadConfig();
    }

    loadConfig() {
      try {
        const saved = GM_getValue('forumAssistantConfig', '{}');
        return { ...this.defaultConfig, ...JSON.parse(saved) };
      } catch (e) {
        console.warn('é…ç½®åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®:', e);
        return { ...this.defaultConfig };
      }
    }

    saveConfig() {
      try {
        GM_setValue('forumAssistantConfig', JSON.stringify(this.config));
        return true;
      } catch (e) {
        console.error('é…ç½®ä¿å­˜å¤±è´¥:', e);
        return false;
      }
    }

    get(key) {
      return this.config[key];
    }

    set(key, value) {
      this.config[key] = value;
      this.saveConfig();
    }

    reset() {
      this.config = { ...this.defaultConfig };
      this.saveConfig();
    }

    exportConfig() {
      return JSON.stringify(this.config, null, 2);
    }

    importConfig(configStr) {
      try {
        const imported = JSON.parse(configStr);
        this.config = { ...this.defaultConfig, ...imported };
        this.saveConfig();
        return true;
      } catch (e) {
        console.error('é…ç½®å¯¼å…¥å¤±è´¥:', e);
        return false;
      }
    }
  }

  // ===== å·¥å…·ç±» =====
  class Utils {
    static getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    static getRandomFloat(min, max) {
      return Math.random() * (max - min) + min;
    }

    static sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // å®‰å…¨çš„DOMå…ƒç´ åˆ›å»º
    static safeCreateElement(tagName, options = {}) {
      try {
        const element = document.createElement(tagName);
        if (!element) {
          console.error(`æ— æ³•åˆ›å»º ${tagName} å…ƒç´ `);
          return null;
        }

        // è®¾ç½®å±æ€§
        if (options.id) element.id = options.id;
        if (options.className) element.className = options.className;
        if (options.textContent) element.textContent = options.textContent;
        if (options.innerHTML) element.innerHTML = options.innerHTML;

        // è®¾ç½®æ ·å¼
        if (options.style && typeof options.style === 'object') {
          Object.assign(element.style, options.style);
        }

        return element;
      } catch (e) {
        console.error(`åˆ›å»º ${tagName} å…ƒç´ å¤±è´¥:`, e);
        return null;
      }
    }

    // å®‰å…¨çš„DOMå…ƒç´ æŸ¥æ‰¾
    static safeQuerySelector(selector, parent = document) {
      try {
        if (!parent || typeof parent.querySelector !== 'function') {
          console.warn('æ— æ•ˆçš„çˆ¶å…ƒç´ ');
          return null;
        }
        return parent.querySelector(selector);
      } catch (e) {
        console.error(`æŸ¥æ‰¾å…ƒç´ å¤±è´¥ (${selector}):`, e);
        return null;
      }
    }

    // å®‰å…¨çš„DOMå…ƒç´ æ·»åŠ 
    static safeAppendChild(parent, child) {
      try {
        if (!parent || !child) {
          console.warn('çˆ¶å…ƒç´ æˆ–å­å…ƒç´ ä¸ºç©º');
          return false;
        }
        if (typeof parent.appendChild !== 'function') {
          console.warn('çˆ¶å…ƒç´ ä¸æ”¯æŒappendChild');
          return false;
        }
        parent.appendChild(child);
        return true;
      } catch (e) {
        console.error('æ·»åŠ å­å…ƒç´ å¤±è´¥:', e);
        return false;
      }
    }

    // å®‰å…¨çš„æ ·å¼è®¾ç½®
    static safeSetStyle(element, property, value) {
      try {
        if (!element || !element.style) {
          console.warn('å…ƒç´ æˆ–æ ·å¼å¯¹è±¡ä¸å­˜åœ¨');
          return false;
        }
        element.style[property] = value;
        return true;
      } catch (e) {
        console.error(`è®¾ç½®æ ·å¼å¤±è´¥ (${property}):`, e);
        return false;
      }
    }

    // å®‰å…¨çš„å†…å®¹è®¾ç½®
    static safeSetContent(element, content, useInnerHTML = false) {
      try {
        if (!element) {
          console.warn('å…ƒç´ ä¸å­˜åœ¨');
          return false;
        }
        if (useInnerHTML) {
          element.innerHTML = content;
        } else {
          element.textContent = content;
        }
        return true;
      } catch (e) {
        console.error('è®¾ç½®å†…å®¹å¤±è´¥:', e);
        return false;
      }
    }

    static formatTime(ms) {
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);

      if (hours > 0) {
        return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
      } else if (minutes > 0) {
        return `${minutes}m ${seconds % 60}s`;
      } else {
        return `${seconds}s`;
      }
    }

    static formatNumber(num) {
      if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
      } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
      }
      return num.toString();
    }

    static debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    static throttle(func, limit) {
      let inThrottle;
      return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
          func.apply(context, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      };
    }

    static generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    static detectForumType(url) {
      if (url.includes('discourse')) return 'discourse';
      if (url.includes('linux.do')) return 'discourse';
      if (url.includes('www.nodeloc.com')) return 'discourse';
      if (url.includes('greasyfork.org')) return 'greasyfork';
      return 'unknown';
    }

    static cubicBezier(t, p0, p1, p2, p3) {
      const u = 1 - t;
      const tt = t * t;
      const uu = u * u;
      const uuu = uu * u;
      const ttt = tt * t;
      return uuu * p0 + 3 * uu * t * p1 + 3 * u * tt * p2 + ttt * p3;
    }
  }

  // ===== æ—¥å¿—ç®¡ç†ç±» =====
  class LogManager {
    constructor(config) {
      this.config = config;
      this.entries = [];
      this.logWindow = null;
      this.logContent = null;
      // ä»å­˜å‚¨ä¸­æ¢å¤ç»Ÿè®¡æ•°æ®ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ä½¿ç”¨é»˜è®¤å€¼
      const savedStats = GM_getValue('statistics', null);
      if (savedStats) {
        this.statistics = {
          totalActions: savedStats.totalActions || 0,
          totalReadTime: savedStats.totalReadTime || 0,
          topicsRead: savedStats.topicsRead || 0,
          likesGiven: savedStats.likesGiven || 0,
          errorsCount: savedStats.errorsCount || 0,
          startTime: savedStats.startTime || Date.now()
        };
      } else {
        this.statistics = {
          totalActions: 0,
          totalReadTime: 0,
          topicsRead: 0,
          likesGiven: 0,
          errorsCount: 0,
          startTime: Date.now()
        };
      }
    }

    createLogWindow() {
      if (this.logWindow) return;

      const isDark = this.config.get('theme') === 'dark';
      const isCompact = this.config.get('compactMode');

      this.logWindow = Utils.safeCreateElement("div", {
        id: "forum-assistant-log",
        style: {
          position: "fixed",
          top: "10px",
          right: "10px",
          width: isCompact ? "280px" : "350px",
          maxHeight: isCompact ? "300px" : "500px",
          backgroundColor: isDark ? "#2d3748" : "#fff",
          color: isDark ? "#e2e8f0" : "#2d3748",
          border: `1px solid ${isDark ? "#4a5568" : "#e2e8f0"}`,
          borderRadius: "8px",
          boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
          zIndex: "10000",
          display: "flex",
          flexDirection: "column",
          fontFamily: "'Consolas', 'Monaco', monospace",
          fontSize: isCompact ? "11px" : "12px",
          backdropFilter: "blur(10px)",
          resize: "both",
          overflow: "hidden"
        }
      });

      if (!this.logWindow) {
        console.error('æ— æ³•åˆ›å»ºæ—¥å¿—çª—å£');
        return;
      }

      this.createLogHeader(isDark);
      this.createLogContent(isDark);
      this.createLogControls(isDark);

      if (!Utils.safeAppendChild(document.body, this.logWindow)) {
        console.error('æ— æ³•æ·»åŠ æ—¥å¿—çª—å£åˆ°é¡µé¢');
        return;
      }

      this.makeResizable();
    }

    createLogHeader(isDark) {
      const header = document.createElement("div");
      Object.assign(header.style, {
        backgroundColor: isDark ? "#4a5568" : "#f7fafc",
        padding: "8px 12px",
        borderBottom: `1px solid ${isDark ? "#718096" : "#e2e8f0"}`,
        fontWeight: "bold",
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        cursor: "move"
      });

      const title = document.createElement("span");
      title.textContent = "æ™ºèƒ½è®ºå›åŠ©æ‰‹ Pro";

      const controls = document.createElement("div");
      controls.style.display = "flex";
      controls.style.gap = "5px";

      // æœ€å°åŒ–æŒ‰é’®
      const minimizeBtn = this.createControlButton("âˆ’", () => this.toggleMinimize());
      // å…³é—­æŒ‰é’®
      const closeBtn = this.createControlButton("Ã—", () => this.toggleVisibility());

      controls.appendChild(minimizeBtn);
      controls.appendChild(closeBtn);
      header.appendChild(title);
      header.appendChild(controls);
      this.logWindow.appendChild(header);

      // ä½¿çª—å£å¯æ‹–æ‹½
      this.makeDraggable(header);
    }

    createLogContent(isDark) {
      this.logContent = Utils.safeCreateElement("pre", {
        style: {
          margin: "0",
          padding: "10px",
          overflowY: "auto",
          flex: "1",
          fontSize: "inherit",
          lineHeight: "1.4",
          whiteSpace: "pre-wrap",
          wordBreak: "break-word"
        }
      });

      if (this.logContent && this.logWindow) {
        Utils.safeAppendChild(this.logWindow, this.logContent);
      }
    }

    createLogControls(isDark) {
      const controls = document.createElement("div");
      Object.assign(controls.style, {
        padding: "8px",
        borderTop: `1px solid ${isDark ? "#718096" : "#e2e8f0"}`,
        display: "flex",
        gap: "5px",
        flexWrap: "wrap"
      });

      const clearBtn = this.createActionButton("æ¸…ç©º", () => this.clear());
      const exportBtn = this.createActionButton("å¯¼å‡º", () => this.exportLogs());
      const statsBtn = this.createActionButton("ç»Ÿè®¡", () => this.showStatistics());

      controls.appendChild(clearBtn);
      controls.appendChild(exportBtn);
      controls.appendChild(statsBtn);
      this.logWindow.appendChild(controls);
    }

    createControlButton(text, onClick) {
      const btn = document.createElement("button");
      btn.textContent = text;
      Object.assign(btn.style, {
        background: "none",
        border: "none",
        color: "inherit",
        cursor: "pointer",
        padding: "2px 6px",
        borderRadius: "3px",
        fontSize: "14px",
        fontWeight: "bold"
      });
      btn.addEventListener("click", onClick);
      btn.addEventListener("mouseenter", () => {
        btn.style.backgroundColor = "rgba(255,255,255,0.1)";
      });
      btn.addEventListener("mouseleave", () => {
        btn.style.backgroundColor = "transparent";
      });
      return btn;
    }

    createActionButton(text, onClick) {
      const btn = document.createElement("button");
      btn.textContent = text;
      Object.assign(btn.style, {
        padding: "4px 8px",
        border: "1px solid currentColor",
        backgroundColor: "transparent",
        color: "inherit",
        cursor: "pointer",
        borderRadius: "4px",
        fontSize: "11px"
      });
      btn.addEventListener("click", onClick);
      return btn;
    }

    makeDraggable(header) {
      if (!header || !this.logWindow) return;

      let isDragging = false;
      let currentX, currentY, initialX, initialY;

      header.addEventListener("mousedown", (e) => {
        if (!this.logWindow) return;
        isDragging = true;
        initialX = e.clientX - this.logWindow.offsetLeft;
        initialY = e.clientY - this.logWindow.offsetTop;
      });

      document.addEventListener("mousemove", (e) => {
        if (isDragging && this.logWindow) {
          e.preventDefault();
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
          this.logWindow.style.left = currentX + "px";
          this.logWindow.style.top = currentY + "px";
          this.logWindow.style.right = "auto";
        }
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
      });
    }

    makeResizable() {
      if (!this.logWindow) return;

      // ç®€å•çš„è°ƒæ•´å¤§å°åŠŸèƒ½
      const resizer = document.createElement("div");
      Object.assign(resizer.style, {
        position: "absolute",
        bottom: "0",
        right: "0",
        width: "10px",
        height: "10px",
        cursor: "se-resize",
        backgroundColor: "rgba(128,128,128,0.3)"
      });
      this.logWindow.appendChild(resizer);

      let isResizing = false;
      resizer.addEventListener("mousedown", (e) => {
        isResizing = true;
        e.preventDefault();
      });

      document.addEventListener("mousemove", (e) => {
        if (isResizing && this.logWindow) {
          const rect = this.logWindow.getBoundingClientRect();
          const newWidth = e.clientX - rect.left;
          const newHeight = e.clientY - rect.top;

          if (newWidth > 200) this.logWindow.style.width = newWidth + "px";
          if (newHeight > 150) this.logWindow.style.height = newHeight + "px";
        }
      });

      document.addEventListener("mouseup", () => {
        isResizing = false;
      });
    }

    log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const entry = {
        timestamp,
        message,
        type,
        id: Utils.generateUUID()
      };

      this.entries.push(entry);
      this.statistics.totalActions++;

      if (type === 'error') this.statistics.errorsCount++;

      // é™åˆ¶æ—¥å¿—æ¡ç›®æ•°é‡
      const maxEntries = this.config.get('maxLogEntries');
      if (this.entries.length > maxEntries) {
        this.entries = this.entries.slice(-maxEntries);
      }

      this.updateLogDisplay();

      // æ§åˆ¶å°è¾“å‡º
      const consoleMethod = type === 'error' ? 'error' : type === 'warn' ? 'warn' : 'log';
      console[consoleMethod](`[è®ºå›åŠ©æ‰‹] [${timestamp}] ${message}`);

      // é‡è¦æ¶ˆæ¯é€šçŸ¥
      if (type === 'error' || (type === 'info' && message.includes('å®Œæˆ'))) {
        this.showNotification(message, type);
      }
    }

    updateLogDisplay() {
      if (!this.logContent) {
        console.warn('æ—¥å¿—å†…å®¹å…ƒç´ ä¸å­˜åœ¨');
        return;
      }

      try {
        const displayEntries = this.entries.map(entry => {
          const typeIcon = this.getTypeIcon(entry.type);
          return `${typeIcon} [${entry.timestamp}] ${entry.message}`;
        });

        this.logContent.textContent = displayEntries.join('\n');
        this.logContent.scrollTop = this.logContent.scrollHeight;
      } catch (e) {
        console.error('æ›´æ–°æ—¥å¿—æ˜¾ç¤ºå¤±è´¥:', e);
      }
    }

    getTypeIcon(type) {
      const icons = {
        info: 'ğŸ“˜',
        warn: 'âš ï¸',
        error: 'âŒ',
        success: 'âœ…',
        action: 'ğŸ”„'
      };
      return icons[type] || 'ğŸ“˜';
    }

    showNotification(message, type) {
      if (typeof GM_notification !== 'undefined') {
        GM_notification({
          text: message,
          title: 'æ™ºèƒ½è®ºå›åŠ©æ‰‹',
          timeout: 3000,
          onclick: () => {
            window.focus();
            this.logWindow?.scrollIntoView();
          }
        });
      }
    }

    clear() {
      this.entries = [];
      this.updateLogDisplay();
      this.log('æ—¥å¿—å·²æ¸…ç©º', 'action');
    }

    exportLogs() {
      const exportData = {
        timestamp: new Date().toISOString(),
        statistics: this.statistics,
        logs: this.entries,
        config: this.config.config
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], {
        type: 'application/json'
      });

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `forum-assistant-logs-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      this.log('æ—¥å¿—å·²å¯¼å‡º', 'success');
    }

    showStatistics() {
      const runtime = Date.now() - this.statistics.startTime;
      const stats = `
ğŸ“Š è¿è¡Œç»Ÿè®¡
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â±ï¸ è¿è¡Œæ—¶é—´: ${Utils.formatTime(runtime)}
ğŸ“– å·²è¯»è¯é¢˜: ${this.statistics.topicsRead}
ğŸ‘ ç‚¹èµæ•°é‡: ${this.statistics.likesGiven}
ğŸ”„ æ€»æ“ä½œæ•°: ${this.statistics.totalActions}
âŒ é”™è¯¯æ¬¡æ•°: ${this.statistics.errorsCount}
ğŸ“ˆ æ•ˆç‡: ${(this.statistics.topicsRead / (runtime / 3600000)).toFixed(2)} è¯é¢˜/å°æ—¶
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`;

      alert(stats);
    }

    toggleMinimize() {
      if (!this.logWindow) return;

      const content = this.logWindow.querySelector('pre');
      const controls = this.logWindow.querySelector('div:last-child');

      if (!content || !controls) return;

      if (content.style.display === 'none') {
        content.style.display = 'block';
        controls.style.display = 'flex';
        this.logWindow.style.height = 'auto';
      } else {
        content.style.display = 'none';
        controls.style.display = 'none';
        this.logWindow.style.height = 'auto';
      }
    }

    toggleVisibility() {
      if (!this.logWindow) return;
      this.logWindow.style.display = this.logWindow.style.display === 'none' ? 'flex' : 'none';
    }

    updateStatistics(key, value = 1) {
      if (this.statistics.hasOwnProperty(key)) {
        this.statistics[key] += value;
        // ä¿å­˜ç»Ÿè®¡æ•°æ®åˆ°å­˜å‚¨
        GM_setValue('statistics', this.statistics);
      }
    }

    // é‡ç½®ç»Ÿè®¡æ•°æ®
    resetStatistics() {
      this.statistics = {
        totalActions: 0,
        totalReadTime: 0,
        topicsRead: 0,
        likesGiven: 0,
        errorsCount: 0,
        startTime: Date.now()
      };
      GM_setValue('statistics', this.statistics);
      this.log('ç»Ÿè®¡æ•°æ®å·²é‡ç½®', 'info');
    }
  }

  // ===== é…ç½®é¢æ¿ç±» =====
  class ConfigPanel {
    constructor(config, logger) {
      this.config = config;
      this.logger = logger;
      this.panel = null;
      this.isVisible = false;
    }

    create() {
      if (this.panel) return;

      const isDark = this.config.get('theme') === 'dark';

      this.panel = document.createElement('div');
      this.panel.id = 'forum-assistant-config';
      Object.assign(this.panel.style, {
        position: 'fixed',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        width: '600px',
        maxHeight: '80vh',
        backgroundColor: isDark ? '#2d3748' : '#ffffff',
        color: isDark ? '#e2e8f0' : '#2d3748',
        border: `1px solid ${isDark ? '#4a5568' : '#e2e8f0'}`,
        borderRadius: '12px',
        boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
        zIndex: '10001',
        display: 'none',
        flexDirection: 'column',
        fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
        backdropFilter: 'blur(10px)'
      });

      this.createHeader();
      this.createContent();
      this.createFooter();

      document.body.appendChild(this.panel);
      this.createOverlay();
    }

    createHeader() {
      const header = document.createElement('div');
      Object.assign(header.style, {
        padding: '20px',
        borderBottom: `1px solid ${this.config.get('theme') === 'dark' ? '#4a5568' : '#e2e8f0'}`,
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center'
      });

      const title = document.createElement('h2');
      title.textContent = 'ğŸ› ï¸ é«˜çº§é…ç½®';
      title.style.margin = '0';
      title.style.fontSize = '20px';
      title.style.fontWeight = '600';

      const closeBtn = document.createElement('button');
      closeBtn.innerHTML = 'âœ•';
      Object.assign(closeBtn.style, {
        background: 'none',
        border: 'none',
        fontSize: '18px',
        cursor: 'pointer',
        color: 'inherit',
        padding: '5px',
        borderRadius: '4px'
      });
      closeBtn.addEventListener('click', () => this.hide());

      header.appendChild(title);
      header.appendChild(closeBtn);
      this.panel.appendChild(header);
    }

    createContent() {
      const content = document.createElement('div');
      Object.assign(content.style, {
        padding: '20px',
        overflowY: 'auto',
        flex: '1'
      });

      // åˆ›å»ºæ ‡ç­¾é¡µ
      const tabs = this.createTabs();
      content.appendChild(tabs);

      // åˆ›å»ºé…ç½®åŒºåŸŸ
      const configArea = document.createElement('div');
      configArea.id = 'config-area';
      content.appendChild(configArea);

      this.panel.appendChild(content);

      // é»˜è®¤æ˜¾ç¤ºåŸºç¡€é…ç½®
      this.showBasicConfig();
    }

    createTabs() {
      const tabContainer = document.createElement('div');
      Object.assign(tabContainer.style, {
        display: 'flex',
        marginBottom: '20px',
        borderBottom: `1px solid ${this.config.get('theme') === 'dark' ? '#4a5568' : '#e2e8f0'}`
      });

      const tabs = [
        { id: 'basic', name: 'åŸºç¡€è®¾ç½®', icon: 'âš™ï¸' },
        { id: 'behavior', name: 'è¡Œä¸ºé…ç½®', icon: 'ğŸ¤–' },
        { id: 'advanced', name: 'é«˜çº§åŠŸèƒ½', icon: 'ğŸš€' },
        { id: 'ui', name: 'ç•Œé¢è®¾ç½®', icon: 'ğŸ¨' },
        { id: 'data', name: 'æ•°æ®ç®¡ç†', icon: 'ğŸ“Š' }
      ];

      tabs.forEach(tab => {
        const tabBtn = document.createElement('button');
        tabBtn.innerHTML = `${tab.icon} ${tab.name}`;
        Object.assign(tabBtn.style, {
          padding: '10px 15px',
          border: 'none',
          background: 'none',
          color: 'inherit',
          cursor: 'pointer',
          borderBottom: '2px solid transparent',
          fontSize: '14px',
          fontWeight: '500'
        });

        tabBtn.addEventListener('click', () => {
          // ç§»é™¤æ‰€æœ‰æ´»åŠ¨çŠ¶æ€
          tabContainer.querySelectorAll('button').forEach(btn => {
            btn.style.borderBottomColor = 'transparent';
            btn.style.opacity = '0.7';
          });

          // è®¾ç½®å½“å‰æ´»åŠ¨çŠ¶æ€
          tabBtn.style.borderBottomColor = '#3182ce';
          tabBtn.style.opacity = '1';

          // æ˜¾ç¤ºå¯¹åº”é…ç½®
          this.showConfigSection(tab.id);
        });

        tabContainer.appendChild(tabBtn);
      });

      // é»˜è®¤æ¿€æ´»ç¬¬ä¸€ä¸ªæ ‡ç­¾
      tabContainer.firstChild.click();

      return tabContainer;
    }

    showConfigSection(sectionId) {
      const configArea = document.getElementById('config-area');
      if (!configArea) {
        console.error('é…ç½®åŒºåŸŸå…ƒç´ æœªæ‰¾åˆ°');
        return;
      }

      configArea.innerHTML = '';

      switch (sectionId) {
        case 'basic':
          this.showBasicConfig();
          break;
        case 'behavior':
          this.showBehaviorConfig();
          break;
        case 'advanced':
          this.showAdvancedConfig();
          break;
        case 'ui':
          this.showUIConfig();
          break;
        case 'data':
          this.showDataConfig();
          break;
      }
    }

    showBasicConfig() {
      const configArea = document.getElementById('config-area');
      if (!configArea) {
        console.error('é…ç½®åŒºåŸŸå…ƒç´ æœªæ‰¾åˆ° (showBasicConfig)');
        return;
      }

      const basicConfigs = [
        { key: 'commentLimit', label: 'è¯„è®ºæ•°é™åˆ¶', type: 'number', min: 100, max: 5000, step: 100, desc: 'è·³è¿‡è¯„è®ºæ•°è¶…è¿‡æ­¤å€¼çš„å¸–å­' },
        { key: 'topicListLimit', label: 'è¯é¢˜ç¼“å­˜æ•°é‡', type: 'number', min: 50, max: 500, step: 50, desc: 'ä¸€æ¬¡è·å–å¹¶ç¼“å­˜çš„è¯é¢˜æ•°é‡' },
        { key: 'likeLimit', label: 'æ¯æ—¥ç‚¹èµé™åˆ¶', type: 'number', min: 10, max: 200, step: 5, desc: 'æ¯æ—¥è‡ªåŠ¨ç‚¹èµçš„æœ€å¤§æ¬¡æ•°' },
        { key: 'minReadTimeLower', label: 'æœ€å°é˜…è¯»æ—¶é—´(ç§’)', type: 'number', min: 30, max: 300, step: 5, desc: 'æ¯ä¸ªå¸–å­çš„æœ€å°é˜…è¯»æ—¶é—´', transform: v => v / 1000, reverseTransform: v => v * 1000 },
        { key: 'minReadTimeUpper', label: 'æœ€å¤§é˜…è¯»æ—¶é—´(ç§’)', type: 'number', min: 60, max: 600, step: 10, desc: 'æ¯ä¸ªå¸–å­çš„æœ€å¤§é˜…è¯»æ—¶é—´', transform: v => v / 1000, reverseTransform: v => v * 1000 },
        { key: 'stuckTimeout', label: 'å¡ä½æ£€æµ‹è¶…æ—¶(ç§’)', type: 'number', min: 5, max: 60, step: 5, desc: 'æ£€æµ‹é¡µé¢å¡ä½çš„è¶…æ—¶æ—¶é—´', transform: v => v / 1000, reverseTransform: v => v * 1000 }
      ];

      basicConfigs.forEach(config => {
        const group = this.createConfigGroup(config);
        if (group && configArea) {
          configArea.appendChild(group);
        }
      });
    }

    showBehaviorConfig() {
      const configArea = document.getElementById('config-area');
      if (!configArea) {
        console.error('é…ç½®åŒºåŸŸå…ƒç´ æœªæ‰¾åˆ° (showBehaviorConfig)');
        return;
      }

      const behaviorConfigs = [
        { key: 'scrollSegmentDistanceMin', label: 'æ»šåŠ¨æœ€å°è·ç¦»(px)', type: 'number', min: 100, max: 1000, step: 50, desc: 'æ¯æ®µæ»šåŠ¨çš„æœ€å°è·ç¦»' },
        { key: 'scrollSegmentDistanceMax', label: 'æ»šåŠ¨æœ€å¤§è·ç¦»(px)', type: 'number', min: 500, max: 2000, step: 100, desc: 'æ¯æ®µæ»šåŠ¨çš„æœ€å¤§è·ç¦»' },
        { key: 'scrollSegmentDurationMin', label: 'æ»šåŠ¨æœ€å°æ—¶é•¿(ms)', type: 'number', min: 1000, max: 5000, step: 250, desc: 'æ¯æ®µæ»šåŠ¨çš„æœ€å°æŒç»­æ—¶é—´' },
        { key: 'scrollSegmentDurationMax', label: 'æ»šåŠ¨æœ€å¤§æ—¶é•¿(ms)', type: 'number', min: 3000, max: 10000, step: 500, desc: 'æ¯æ®µæ»šåŠ¨çš„æœ€å¤§æŒç»­æ—¶é—´' },
        { key: 'randomPauseProbability', label: 'éšæœºæš‚åœæ¦‚ç‡', type: 'range', min: 0, max: 1, step: 0.05, desc: 'æ»šåŠ¨è¿‡ç¨‹ä¸­éšæœºæš‚åœçš„æ¦‚ç‡' },
        { key: 'minTopicChangeDelay', label: 'è¯é¢˜åˆ‡æ¢æœ€å°å»¶è¿Ÿ(ms)', type: 'number', min: 1000, max: 10000, step: 500, desc: 'åˆ‡æ¢è¯é¢˜çš„æœ€å°å»¶è¿Ÿæ—¶é—´' },
        { key: 'maxTopicChangeDelay', label: 'è¯é¢˜åˆ‡æ¢æœ€å¤§å»¶è¿Ÿ(ms)', type: 'number', min: 3000, max: 20000, step: 1000, desc: 'åˆ‡æ¢è¯é¢˜çš„æœ€å¤§å»¶è¿Ÿæ—¶é—´' }
      ];

      behaviorConfigs.forEach(config => {
        const group = this.createConfigGroup(config);
        if (group && configArea) {
          configArea.appendChild(group);
        }
      });
    }

    showAdvancedConfig() {
      const configArea = document.getElementById('config-area');
      if (!configArea) {
        console.error('é…ç½®åŒºåŸŸå…ƒç´ æœªæ‰¾åˆ° (showAdvancedConfig)');
        return;
      }

      const advancedConfigs = [
        { key: 'enableMouseSimulation', label: 'å¯ç”¨é¼ æ ‡æ¨¡æ‹Ÿ', type: 'checkbox', desc: 'æ¨¡æ‹ŸçœŸå®çš„é¼ æ ‡ç§»åŠ¨è½¨è¿¹' },
        { key: 'enableAdvancedBehavior', label: 'å¯ç”¨é«˜çº§è¡Œä¸º', type: 'checkbox', desc: 'åŒ…æ‹¬éšæœºåœç•™ã€é¡µé¢äº¤äº’ç­‰' },
        { key: 'enableDataAnalysis', label: 'å¯ç”¨æ•°æ®åˆ†æ', type: 'checkbox', desc: 'æ”¶é›†å’Œåˆ†æä½¿ç”¨ç»Ÿè®¡æ•°æ®' },
        { key: 'enableSafetyFeatures', label: 'å¯ç”¨å®‰å…¨åŠŸèƒ½', type: 'checkbox', desc: 'åŒ…æ‹¬è¯·æ±‚å¤´éšæœºåŒ–ã€è¡Œä¸ºæ··æ·†ç­‰' },
        { key: 'autoReplyEnabled', label: 'å¯ç”¨è‡ªåŠ¨å›å¤', type: 'checkbox', desc: 'è‡ªåŠ¨å›å¤ç‰¹å®šç±»å‹çš„å¸–å­' },
        { key: 'keywordMonitoring', label: 'å…³é”®è¯ç›‘æ§', type: 'checkbox', desc: 'ç›‘æ§ç‰¹å®šå…³é”®è¯å¹¶æ‰§è¡Œæ“ä½œ' },
        { key: 'proxyEnabled', label: 'å¯ç”¨ä»£ç†', type: 'checkbox', desc: 'é€šè¿‡ä»£ç†æœåŠ¡å™¨å‘é€è¯·æ±‚' }
      ];

      advancedConfigs.forEach(config => {
        const group = this.createConfigGroup(config);
        if (group && configArea) {
          configArea.appendChild(group);
        }
      });

      // æ·»åŠ å…³é”®è¯è®¾ç½®åŒºåŸŸ
      if (this.config.get('keywordMonitoring')) {
        const keywordSection = this.createKeywordSection();
        if (keywordSection && configArea) {
          configArea.appendChild(keywordSection);
        }
      }
    }

    showUIConfig() {
      const configArea = document.getElementById('config-area');
      if (!configArea) {
        console.error('é…ç½®åŒºåŸŸå…ƒç´ æœªæ‰¾åˆ° (showUIConfig)');
        return;
      }

      const uiConfigs = [
        { key: 'theme', label: 'ä¸»é¢˜', type: 'select', options: [
          { value: 'light', label: 'æµ…è‰²ä¸»é¢˜' },
          { value: 'dark', label: 'æ·±è‰²ä¸»é¢˜' },
          { value: 'auto', label: 'è·Ÿéšç³»ç»Ÿ' }
        ], desc: 'é€‰æ‹©ç•Œé¢ä¸»é¢˜' },
        { key: 'language', label: 'è¯­è¨€', type: 'select', options: [
          { value: 'zh-CN', label: 'ç®€ä½“ä¸­æ–‡' },
          { value: 'zh-TW', label: 'ç¹ä½“ä¸­æ–‡' },
          { value: 'en-US', label: 'English' }
        ], desc: 'é€‰æ‹©ç•Œé¢è¯­è¨€' },
        { key: 'showStatistics', label: 'æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯', type: 'checkbox', desc: 'åœ¨ç•Œé¢ä¸­æ˜¾ç¤ºè¿è¡Œç»Ÿè®¡' },
        { key: 'compactMode', label: 'ç´§å‡‘æ¨¡å¼', type: 'checkbox', desc: 'ä½¿ç”¨æ›´ç´§å‡‘çš„ç•Œé¢å¸ƒå±€' },
        { key: 'maxLogEntries', label: 'æœ€å¤§æ—¥å¿—æ¡ç›®', type: 'number', min: 50, max: 1000, step: 50, desc: 'æ—¥å¿—çª—å£ä¿ç•™çš„æœ€å¤§æ¡ç›®æ•°' }
      ];

      uiConfigs.forEach(config => {
        const group = this.createConfigGroup(config);
        if (group && configArea) {
          configArea.appendChild(group);
        }
      });
    }

    showDataConfig() {
      const configArea = document.getElementById('config-area');
      if (!configArea) {
        console.error('é…ç½®åŒºåŸŸå…ƒç´ æœªæ‰¾åˆ° (showDataConfig)');
        return;
      }

      // æ•°æ®ç®¡ç†åŒºåŸŸ
      const dataSection = document.createElement('div');
      if (!dataSection) {
        console.error('æ— æ³•åˆ›å»ºæ•°æ®ç®¡ç†åŒºåŸŸ');
        return;
      }

      dataSection.innerHTML = `
        <h3 style="margin-top: 0; color: inherit;">ğŸ“Š æ•°æ®ç®¡ç†</h3>
        <div style="display: grid; gap: 15px;">
          <div style="padding: 15px; border: 1px solid currentColor; border-radius: 8px; opacity: 0.8;">
            <h4 style="margin: 0 0 10px 0;">é…ç½®ç®¡ç†</h4>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
              <button id="export-config" style="padding: 8px 16px; border: 1px solid currentColor; background: transparent; color: inherit; border-radius: 4px; cursor: pointer;">å¯¼å‡ºé…ç½®</button>
              <button id="import-config" style="padding: 8px 16px; border: 1px solid currentColor; background: transparent; color: inherit; border-radius: 4px; cursor: pointer;">å¯¼å…¥é…ç½®</button>
              <button id="reset-config" style="padding: 8px 16px; border: 1px solid #dc3545; background: transparent; color: #dc3545; border-radius: 4px; cursor: pointer;">é‡ç½®é…ç½®</button>
            </div>
          </div>
          <div style="padding: 15px; border: 1px solid currentColor; border-radius: 8px; opacity: 0.8;">
            <h4 style="margin: 0 0 10px 0;">æ•°æ®æ¸…ç†</h4>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
              <button id="clear-logs" style="padding: 8px 16px; border: 1px solid currentColor; background: transparent; color: inherit; border-radius: 4px; cursor: pointer;">æ¸…ç©ºæ—¥å¿—</button>
              <button id="clear-cache" style="padding: 8px 16px; border: 1px solid currentColor; background: transparent; color: inherit; border-radius: 4px; cursor: pointer;">æ¸…ç©ºç¼“å­˜</button>
              <button id="clear-all" style="padding: 8px 16px; border: 1px solid #dc3545; background: transparent; color: #dc3545; border-radius: 4px; cursor: pointer;">æ¸…ç©ºæ‰€æœ‰æ•°æ®</button>
            </div>
          </div>
        </div>
      `;

      try {
        configArea.appendChild(dataSection);
        // ç»‘å®šäº‹ä»¶
        this.bindDataManagementEvents();
      } catch (e) {
        console.error('æ·»åŠ æ•°æ®ç®¡ç†åŒºåŸŸå¤±è´¥:', e);
      }
    }

    createConfigGroup(config) {
      const group = document.createElement('div');
      Object.assign(group.style, {
        marginBottom: '20px',
        padding: '15px',
        border: `1px solid ${this.config.get('theme') === 'dark' ? '#4a5568' : '#e2e8f0'}`,
        borderRadius: '8px',
        backgroundColor: this.config.get('theme') === 'dark' ? '#374151' : '#f8fafc'
      });

      const label = document.createElement('label');
      label.style.display = 'block';
      label.style.marginBottom = '8px';
      label.style.fontWeight = '500';
      label.innerHTML = `${config.label} ${config.desc ? `<small style="opacity: 0.7; font-weight: normal;">(${config.desc})</small>` : ''}`;

      let input;
      const currentValue = config.transform ? config.transform(this.config.get(config.key)) : this.config.get(config.key);

      switch (config.type) {
        case 'number':
          input = document.createElement('input');
          input.type = 'number';
          input.min = config.min;
          input.max = config.max;
          input.step = config.step;
          input.value = currentValue;
          break;

        case 'range':
          const container = document.createElement('div');
          container.style.display = 'flex';
          container.style.alignItems = 'center';
          container.style.gap = '10px';

          input = document.createElement('input');
          input.type = 'range';
          input.min = config.min;
          input.max = config.max;
          input.step = config.step;
          input.value = currentValue;

          const valueDisplay = document.createElement('span');
          valueDisplay.textContent = currentValue;
          valueDisplay.style.minWidth = '50px';
          valueDisplay.style.textAlign = 'center';
          valueDisplay.style.fontSize = '14px';

          input.addEventListener('input', () => {
            valueDisplay.textContent = input.value;
          });

          container.appendChild(input);
          container.appendChild(valueDisplay);
          group.appendChild(label);
          group.appendChild(container);

          input.addEventListener('change', () => {
            this.config.set(config.key, parseFloat(input.value));
            this.logger.log(`é…ç½®å·²æ›´æ–°: ${config.label} = ${input.value}`, 'action');
          });

          return group;

        case 'checkbox':
          input = document.createElement('input');
          input.type = 'checkbox';
          input.checked = currentValue;
          input.style.marginRight = '8px';

          const checkboxLabel = document.createElement('label');
          checkboxLabel.style.display = 'flex';
          checkboxLabel.style.alignItems = 'center';
          checkboxLabel.style.cursor = 'pointer';
          checkboxLabel.appendChild(input);
          checkboxLabel.appendChild(document.createTextNode(config.label));

          if (config.desc) {
            const desc = document.createElement('div');
            desc.style.fontSize = '12px';
            desc.style.opacity = '0.7';
            desc.style.marginTop = '4px';
            desc.textContent = config.desc;
            group.appendChild(checkboxLabel);
            group.appendChild(desc);
          } else {
            group.appendChild(checkboxLabel);
          }

          input.addEventListener('change', () => {
            this.config.set(config.key, input.checked);
            this.logger.log(`é…ç½®å·²æ›´æ–°: ${config.label} = ${input.checked}`, 'action');

            // ç‰¹æ®Šå¤„ç†æŸäº›é…ç½®å˜æ›´
            if (config.key === 'theme') {
              this.applyTheme();
            }
          });

          return group;

        case 'select':
          input = document.createElement('select');
          config.options.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option.value;
            optionElement.textContent = option.label;
            optionElement.selected = option.value === currentValue;
            input.appendChild(optionElement);
          });
          break;

        default:
          input = document.createElement('input');
          input.type = 'text';
          input.value = currentValue;
      }

      // é€šç”¨æ ·å¼
      if (input && config.type !== 'checkbox') {
        Object.assign(input.style, {
          width: '100%',
          padding: '8px 12px',
          border: `1px solid ${this.config.get('theme') === 'dark' ? '#4a5568' : '#d1d5db'}`,
          borderRadius: '6px',
          backgroundColor: this.config.get('theme') === 'dark' ? '#1f2937' : '#ffffff',
          color: 'inherit',
          fontSize: '14px'
        });

        // é€šç”¨äº‹ä»¶å¤„ç†
        input.addEventListener('change', () => {
          let value = input.value;
          if (config.type === 'number') {
            value = parseFloat(value);
            if (config.reverseTransform) {
              value = config.reverseTransform(value);
            }
          }
          this.config.set(config.key, value);
          this.logger.log(`é…ç½®å·²æ›´æ–°: ${config.label} = ${input.value}`, 'action');

          // ç‰¹æ®Šå¤„ç†
          if (config.key === 'theme') {
            this.applyTheme();
          }
        });
      }

      if (config.type !== 'checkbox') {
        group.appendChild(label);
        group.appendChild(input);
      }

      return group;
    }

    bindDataManagementEvents() {
      // å¯¼å‡ºé…ç½®
      document.getElementById('export-config')?.addEventListener('click', () => {
        const configStr = this.config.exportConfig();
        const blob = new Blob([configStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `forum-assistant-config-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        this.logger.log('é…ç½®å·²å¯¼å‡º', 'success');
      });

      // å¯¼å…¥é…ç½®
      document.getElementById('import-config')?.addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const success = this.config.importConfig(e.target.result);
                if (success) {
                  this.logger.log('é…ç½®å¯¼å…¥æˆåŠŸ', 'success');
                  this.hide();
                  setTimeout(() => location.reload(), 1000);
                } else {
                  this.logger.log('é…ç½®å¯¼å…¥å¤±è´¥', 'error');
                }
              } catch (error) {
                this.logger.log(`é…ç½®å¯¼å…¥é”™è¯¯: ${error.message}`, 'error');
              }
            };
            reader.readAsText(file);
          }
        });
        input.click();
      });

      // é‡ç½®é…ç½®
      document.getElementById('reset-config')?.addEventListener('click', () => {
        if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰é…ç½®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
          this.config.reset();
          this.logger.log('é…ç½®å·²é‡ç½®', 'action');
          this.hide();
          setTimeout(() => location.reload(), 1000);
        }
      });

      // æ¸…ç©ºæ—¥å¿—
      document.getElementById('clear-logs')?.addEventListener('click', () => {
        this.logger.clear();
      });

      // æ¸…ç©ºç¼“å­˜
      document.getElementById('clear-cache')?.addEventListener('click', () => {
        if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç¼“å­˜æ•°æ®å—ï¼Ÿ')) {
          GM_listValues().forEach(key => {
            if (key.startsWith('topicList') || key.startsWith('latestPage')) {
              GM_deleteValue(key);
            }
          });
          this.logger.log('ç¼“å­˜å·²æ¸…ç©º', 'action');
        }
      });

      // æ¸…ç©ºæ‰€æœ‰æ•°æ®
      document.getElementById('clear-all')?.addEventListener('click', () => {
        if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿè¿™å°†åˆ é™¤æ‰€æœ‰é…ç½®ã€æ—¥å¿—å’Œç¼“å­˜æ•°æ®ã€‚')) {
          GM_listValues().forEach(key => GM_deleteValue(key));
          this.logger.log('æ‰€æœ‰æ•°æ®å·²æ¸…ç©º', 'action');
          setTimeout(() => location.reload(), 1000);
        }
      });
    }

    createKeywordSection() {
      const section = document.createElement('div');
      section.style.marginTop = '20px';
      section.innerHTML = `
        <h4 style="margin: 0 0 15px 0; color: inherit;">ğŸ” å…³é”®è¯ç›‘æ§è®¾ç½®</h4>
        <div style="display: grid; gap: 10px;">
          <div>
            <label style="display: block; margin-bottom: 5px; font-weight: 500;">ç›‘æ§å…³é”®è¯ (æ¯è¡Œä¸€ä¸ª):</label>
            <textarea id="keywords-input" style="width: 100%; height: 100px; padding: 8px; border: 1px solid currentColor; border-radius: 4px; background: transparent; color: inherit; resize: vertical;" placeholder="è¾“å…¥è¦ç›‘æ§çš„å…³é”®è¯ï¼Œæ¯è¡Œä¸€ä¸ª"></textarea>
          </div>
          <div>
            <label style="display: block; margin-bottom: 5px; font-weight: 500;">è§¦å‘åŠ¨ä½œ:</label>
            <select id="keyword-action" style="width: 100%; padding: 8px; border: 1px solid currentColor; border-radius: 4px; background: transparent; color: inherit;">
              <option value="like">è‡ªåŠ¨ç‚¹èµ</option>
              <option value="reply">è‡ªåŠ¨å›å¤</option>
              <option value="notify">ä»…é€šçŸ¥</option>
              <option value="collect">æ”¶è—å¸–å­</option>
            </select>
          </div>
        </div>
      `;

      // åŠ è½½å·²ä¿å­˜çš„å…³é”®è¯
      const savedKeywords = this.config.get('monitorKeywords') || [];
      const keywordsInput = section.querySelector('#keywords-input');
      keywordsInput.value = savedKeywords.join('\n');

      // ä¿å­˜å…³é”®è¯
      keywordsInput.addEventListener('blur', () => {
        const keywords = keywordsInput.value.split('\n').filter(k => k.trim());
        this.config.set('monitorKeywords', keywords);
        this.logger.log(`å…³é”®è¯å·²æ›´æ–°: ${keywords.length} ä¸ª`, 'action');
      });

      return section;
    }

    createFooter() {
      const footer = document.createElement('div');
      Object.assign(footer.style, {
        padding: '20px',
        borderTop: `1px solid ${this.config.get('theme') === 'dark' ? '#4a5568' : '#e2e8f0'}`,
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center'
      });

      const version = document.createElement('span');
      version.textContent = 'v2.0.0';
      version.style.opacity = '0.6';
      version.style.fontSize = '12px';

      const buttons = document.createElement('div');
      buttons.style.display = 'flex';
      buttons.style.gap = '10px';

      const saveBtn = document.createElement('button');
      saveBtn.textContent = 'ä¿å­˜è®¾ç½®';
      Object.assign(saveBtn.style, {
        padding: '8px 16px',
        backgroundColor: '#3182ce',
        color: 'white',
        border: 'none',
        borderRadius: '6px',
        cursor: 'pointer',
        fontSize: '14px',
        fontWeight: '500'
      });
      saveBtn.addEventListener('click', () => {
        this.config.saveConfig();
        this.logger.log('é…ç½®å·²ä¿å­˜', 'success');
        this.hide();
      });

      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'å–æ¶ˆ';
      Object.assign(cancelBtn.style, {
        padding: '8px 16px',
        backgroundColor: 'transparent',
        color: 'inherit',
        border: '1px solid currentColor',
        borderRadius: '6px',
        cursor: 'pointer',
        fontSize: '14px'
      });
      cancelBtn.addEventListener('click', () => this.hide());

      buttons.appendChild(cancelBtn);
      buttons.appendChild(saveBtn);
      footer.appendChild(version);
      footer.appendChild(buttons);
      this.panel.appendChild(footer);
    }

    createOverlay() {
      this.overlay = document.createElement('div');
      Object.assign(this.overlay.style, {
        position: 'fixed',
        top: '0',
        left: '0',
        width: '100%',
        height: '100%',
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        zIndex: '10000',
        display: 'none'
      });
      this.overlay.addEventListener('click', () => this.hide());
      document.body.appendChild(this.overlay);
    }

    show() {
      if (!this.panel) this.create();
      this.panel.style.display = 'flex';
      this.overlay.style.display = 'block';
      this.isVisible = true;
    }

    hide() {
      if (this.panel) this.panel.style.display = 'none';
      if (this.overlay) this.overlay.style.display = 'none';
      this.isVisible = false;
    }

    toggle() {
      if (this.isVisible) {
        this.hide();
      } else {
        this.show();
      }
    }

    applyTheme() {
      // é‡æ–°åˆ›å»ºé¢æ¿ä»¥åº”ç”¨æ–°ä¸»é¢˜
      if (this.panel) {
        this.panel.remove();
        this.panel = null;
      }
      if (this.isVisible) {
        this.create();
        this.show();
      }
    }
  }

  // ===== ç»Ÿè®¡é¢æ¿ç±» =====
  class StatisticsPanel {
    constructor(config, logger) {
      this.config = config;
      this.logger = logger;
      this.panel = null;
      this.isVisible = false;
      this.updateInterval = null;
      this.energyValue = 'åŠ è½½ä¸­...';
    }

    create() {
      if (this.panel) return;

      const isDark = this.config.get('theme') === 'dark';

      this.panel = document.createElement('div');
      this.panel.id = 'forum-assistant-stats';
      Object.assign(this.panel.style, {
        position: 'fixed',
        bottom: '10px',
        left: '10px',
        width: '280px',
        backgroundColor: isDark ? '#2d3748' : '#ffffff',
        color: isDark ? '#e2e8f0' : '#2d3748',
        border: `1px solid ${isDark ? '#4a5568' : '#e2e8f0'}`,
        borderRadius: '8px',
        boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
        zIndex: '9999',
        display: 'none',
        flexDirection: 'column',
        fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
        fontSize: '12px',
        backdropFilter: 'blur(10px)'
      });

      this.createHeader();
      this.createContent();

      document.body.appendChild(this.panel);
    }

    createHeader() {
      const header = document.createElement('div');
      Object.assign(header.style, {
        padding: '10px 12px',
        borderBottom: `1px solid ${this.config.get('theme') === 'dark' ? '#4a5568' : '#e2e8f0'}`,
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        fontWeight: '600'
      });

      const title = document.createElement('span');
      title.textContent = 'ğŸ“Š è¿è¡Œç»Ÿè®¡';

      const toggleBtn = document.createElement('button');
      toggleBtn.innerHTML = 'âˆ’';
      Object.assign(toggleBtn.style, {
        background: 'none',
        border: 'none',
        color: 'inherit',
        cursor: 'pointer',
        fontSize: '16px',
        padding: '2px 6px',
        borderRadius: '3px'
      });
      toggleBtn.addEventListener('click', () => this.toggleMinimize());

      header.appendChild(title);
      header.appendChild(toggleBtn);
      this.panel.appendChild(header);
    }

    createContent() {
      this.content = document.createElement('div');
      Object.assign(this.content.style, {
        padding: '12px',
        display: 'grid',
        gap: '8px'
      });

      this.panel.appendChild(this.content);
      this.updateContent();
    }

    updateContent() {
      if (!this.content) {
        console.warn('ç»Ÿè®¡å†…å®¹å…ƒç´ ä¸å­˜åœ¨');
        return;
      }

      try {
        const stats = this.logger.statistics;
        const runtime = Date.now() - stats.startTime;

        const items = [
          { label: 'â±ï¸ è¿è¡Œæ—¶é—´', value: Utils.formatTime(runtime) },
          { label: 'ğŸ“– å·²è¯»è¯é¢˜', value: stats.topicsRead },
          { label: 'ğŸ‘ ç‚¹èµæ•°é‡', value: stats.likesGiven },
          { label: 'ğŸ”„ æ€»æ“ä½œæ•°', value: stats.totalActions },
          { label: 'âŒ é”™è¯¯æ¬¡æ•°', value: stats.errorsCount },
          { label: 'ğŸ“ˆ é˜…è¯»æ•ˆç‡', value: `${(stats.topicsRead / Math.max(runtime / 3600000, 0.1)).toFixed(1)} è¯é¢˜/å°æ—¶` }
        ];

        this.content.innerHTML = items.map(item => `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0;">
            <span style="opacity: 0.8;">${item.label}</span>
            <span style="font-weight: 600;">${item.value}</span>
          </div>
        `).join('') + `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0;">
            <span style="opacity: 0.8;">âš¡ èƒ½é‡å€¼</span>
            <span style="font-weight: 600;">${this.energyValue}</span>
          </div>
          <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
            <button id="reset-stats" style="width: 100%; padding: 6px 12px; border: 1px solid #dc3545;
                    background: #dc3545; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">
              ğŸ”„ é‡ç½®ç»Ÿè®¡
            </button>
          </div>
        `;
      } catch (e) {
        console.error('æ›´æ–°ç»Ÿè®¡å†…å®¹å¤±è´¥:', e);
      }
    }



    // æ›´æ–°èƒ½é‡æ˜¾ç¤º
    updateEnergyDisplay() {
      if (window.location.hostname !== 'www.nodeloc.com') {
        this.energyValue = 'N/A';
        return;
      }

      GM_xmlhttpRequest({
        method: 'GET',
        url: 'https://www.nodeloc.com/leaderboard/1.json',
        onload: (response) => {
          try {
            const data = JSON.parse(response.responseText);
            let energy = '--';
            if (data && data.personal && data.personal.user && typeof data.personal.user.total_score !== 'undefined') {
              energy = data.personal.user.total_score.toLocaleString();
            }
            this.energyValue = energy;
          } catch (e) {
            this.energyValue = 'é”™è¯¯';
            console.error('[Energy Display] Error parsing data:', e);
          }
        },
        onerror: (error) => {
          this.energyValue = 'å¤±è´¥';
          console.error('[Energy Display] Error fetching data:', error);
        }
      });
    }

    show() {
      if (!this.panel) this.create();
      this.panel.style.display = 'flex';
      this.isVisible = true;

      // ç«‹å³æ›´æ–°ä¸€æ¬¡
      this.updateContent();
      this.updateEnergyDisplay();

      // è®¾ç½®å®šæ—¶å™¨
      if (this.updateInterval) clearInterval(this.updateInterval);
      this.updateInterval = setInterval(() => {
        this.updateContent();
        this.updateEnergyDisplay();
      }, 5000); // 5ç§’åˆ·æ–°ä¸€æ¬¡

      // ç»‘å®šé‡ç½®æŒ‰é’®äº‹ä»¶
      setTimeout(() => {
        const resetBtn = document.getElementById('reset-stats');
        if (resetBtn) {
          resetBtn.addEventListener('click', () => {
            if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰ç»Ÿè®¡æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
              this.logger.resetStatistics();
              this.updateContent();
            }
          });
        }
      }, 100);
    }

    hide() {
      if (this.panel) this.panel.style.display = 'none';
      this.isVisible = false;

      // åœæ­¢æ›´æ–°
      if (this.updateInterval) {
        clearInterval(this.updateInterval);
        this.updateInterval = null;
      }
    }

    toggle() {
      if (this.isVisible) {
        this.hide();
      } else {
        this.show();
      }
    }

    toggleMinimize() {
      if (!this.content || !this.panel) return;

      const toggleBtn = this.panel.querySelector('button');
      if (!toggleBtn) return;

      if (this.content.style.display === 'none') {
        this.content.style.display = 'grid';
        toggleBtn.innerHTML = 'âˆ’';
      } else {
        this.content.style.display = 'none';
        toggleBtn.innerHTML = '+';
      }
    }
  }

  // ===== å‡çº§è¿›åº¦é¢æ¿ç±» =====
  class UpgradeProgressPanel {
    constructor(config, logger) {
      this.config = config;
      this.logger = logger;
      this.panel = null;
      this.isVisible = false;
      this.updateInterval = null;
      this.upgradeProgress = 'åŠ è½½ä¸­...';
      this.unmetConditions = null;
      this.customUsername = GM_getValue('customUsername', '');
      this.currentUsername = null;
    }

    create() {
      if (this.panel) return;

      const isDark = this.config.get('theme') === 'dark';

      this.panel = document.createElement('div');
      this.panel.id = 'forum-assistant-upgrade';

      // è·å–ä¿å­˜çš„ä½ç½®ï¼Œé»˜è®¤ä¸ºå·¦ä¸Šè§’
      const savedPosition = GM_getValue('upgradeProgressPosition', { top: '10px', left: '10px' });

      Object.assign(this.panel.style, {
        position: 'fixed',
        top: savedPosition.top,
        left: savedPosition.left,
        width: '300px',
        backgroundColor: isDark ? '#2d3748' : '#ffffff',
        color: isDark ? '#e2e8f0' : '#2d3748',
        border: `1px solid ${isDark ? '#4a5568' : '#e2e8f0'}`,
        borderRadius: '8px',
        boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
        zIndex: '9998',
        display: 'none',
        flexDirection: 'column',
        fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
        fontSize: '12px',
        backdropFilter: 'blur(10px)'
      });

      this.createHeader();
      this.createContent();

      document.body.appendChild(this.panel);
    }

    createHeader() {
      const header = document.createElement('div');
      Object.assign(header.style, {
        padding: '10px 12px',
        borderBottom: `1px solid ${this.config.get('theme') === 'dark' ? '#4a5568' : '#e2e8f0'}`,
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        fontWeight: '600',
        cursor: 'move',
        userSelect: 'none',
        background: this.config.get('theme') === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.02)'
      });

      const title = document.createElement('span');
      title.textContent = 'ğŸ“ˆ å‡çº§è¿›åº¦';

      const toggleBtn = document.createElement('button');
      toggleBtn.innerHTML = 'âˆ’';
      Object.assign(toggleBtn.style, {
        background: 'none',
        border: 'none',
        color: 'inherit',
        cursor: 'pointer',
        fontSize: '16px',
        padding: '2px 6px',
        borderRadius: '3px'
      });
      toggleBtn.addEventListener('click', () => this.hide());

      header.appendChild(title);
      header.appendChild(toggleBtn);
      this.panel.appendChild(header);

      // ä½¿çª—å£å¯æ‹–æ‹½
      this.makeDraggable(header);
    }

    createContent() {
      this.content = document.createElement('div');
      Object.assign(this.content.style, {
        padding: '15px',
        display: 'flex',
        flexDirection: 'column',
        gap: '12px'
      });

      this.panel.appendChild(this.content);
      this.updateContent();
    }

    updateContent() {
      if (!this.content) return;

      const username = this.getEffectiveUsername();

      this.content.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <span style="opacity: 0.8;">ğŸ‘¤ ç”¨æˆ·å:</span>
          <span style="font-weight: 600;">${username || 'æœªè®¾ç½®'}</span>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <span style="opacity: 0.8;">ğŸ“Š å½“å‰è¿›åº¦:</span>
          <span style="font-weight: 600;">${this.upgradeProgress}</span>
        </div>
        ${this.unmetConditions ? `
        <div style="margin-top: 8px; padding: 8px; background: rgba(255,193,7,0.1); border-radius: 4px; border-left: 3px solid #ffc107;">
          <div style="font-size: 11px; font-weight: 600; margin-bottom: 4px; color: #f59e0b;">âš ï¸ æœªå®Œæˆæ¡ä»¶:</div>
          <div style="font-size: 10px; line-height: 1.4; opacity: 0.9;">
            ${this.unmetConditions.map(condition => `â€¢ ${condition}`).join('<br>')}
          </div>
        </div>
        ` : ''}
        <div style="margin-top: 8px;">
          <input type="text" id="custom-username" placeholder="è¾“å…¥è‡ªå®šä¹‰ç”¨æˆ·å"
                 value="${this.customUsername}"
                 style="width: 100%; padding: 6px 8px; border: 1px solid currentColor; border-radius: 4px;
                        background: transparent; color: inherit; font-size: 12px;">
        </div>
        <div style="margin-top: 8px; display: flex; gap: 8px;">
          <button id="save-username" style="flex: 1; padding: 6px 12px; border: 1px solid #3182ce;
                  background: #3182ce; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">
            ä¿å­˜ç”¨æˆ·å
          </button>
          <button id="refresh-progress" style="flex: 1; padding: 6px 12px; border: 1px solid currentColor;
                  background: transparent; color: inherit; border-radius: 4px; cursor: pointer; font-size: 11px;">
            åˆ·æ–°è¿›åº¦
          </button>
        </div>
        <div style="margin-top: 8px; display: flex; gap: 8px;">
          <button id="test-api" style="flex: 1; padding: 6px 12px; border: 1px solid #e53e3e;
                  background: #e53e3e; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">
            ğŸ”§ æµ‹è¯•API
          </button>
          <button id="reset-position" style="flex: 1; padding: 6px 12px; border: 1px solid #6b7280;
                  background: #6b7280; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">
            ğŸ“ é‡ç½®ä½ç½®
          </button>
        </div>
      `;

      // ç»‘å®šäº‹ä»¶
      this.bindEvents();
    }

    bindEvents() {
      const saveBtn = this.content.querySelector('#save-username');
      const refreshBtn = this.content.querySelector('#refresh-progress');
      const testBtn = this.content.querySelector('#test-api');
      const resetPosBtn = this.content.querySelector('#reset-position');
      const usernameInput = this.content.querySelector('#custom-username');

      if (saveBtn) {
        saveBtn.addEventListener('click', () => {
          const username = usernameInput.value.trim();
          this.customUsername = username;
          GM_setValue('customUsername', username);
          this.logger.log(`è‡ªå®šä¹‰ç”¨æˆ·åå·²ä¿å­˜: ${username || '(æ¸…ç©º)'}`, 'success');
          this.updateContent();
          this.updateUpgradeProgress();
        });
      }

      if (refreshBtn) {
        refreshBtn.addEventListener('click', () => {
          this.updateUpgradeProgress();
          this.logger.log('æ‰‹åŠ¨åˆ·æ–°å‡çº§è¿›åº¦', 'action');
        });
      }

      if (testBtn) {
        testBtn.addEventListener('click', () => {
          this.testApiConnection();
        });
      }

      if (resetPosBtn) {
        resetPosBtn.addEventListener('click', () => {
          this.resetPosition();
        });
      }
    }

    makeDraggable(header) {
      if (!header || !this.panel) return;

      let isDragging = false;
      let currentX, currentY, initialX, initialY;

      header.addEventListener("mousedown", (e) => {
        if (!this.panel) return;
        isDragging = true;
        initialX = e.clientX - this.panel.offsetLeft;
        initialY = e.clientY - this.panel.offsetTop;
        header.style.cursor = 'grabbing';
      });

      document.addEventListener("mousemove", (e) => {
        if (isDragging && this.panel) {
          e.preventDefault();
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;

          // é™åˆ¶åœ¨å±å¹•èŒƒå›´å†…
          const maxX = window.innerWidth - this.panel.offsetWidth;
          const maxY = window.innerHeight - this.panel.offsetHeight;

          currentX = Math.max(0, Math.min(currentX, maxX));
          currentY = Math.max(0, Math.min(currentY, maxY));

          this.panel.style.left = currentX + "px";
          this.panel.style.top = currentY + "px";
          this.panel.style.right = "auto";
          this.panel.style.bottom = "auto";
        }
      });

      document.addEventListener("mouseup", () => {
        if (isDragging && this.panel) {
          isDragging = false;
          header.style.cursor = 'move';

          // ä¿å­˜å½“å‰ä½ç½®
          const position = {
            top: this.panel.style.top,
            left: this.panel.style.left
          };
          GM_setValue('upgradeProgressPosition', position);
          console.log('[Upgrade Progress] ä½ç½®å·²ä¿å­˜:', position);
        }
      });
    }

    getEffectiveUsername() {
      // ä¼˜å…ˆä½¿ç”¨è‡ªå®šä¹‰ç”¨æˆ·å
      if (this.customUsername) {
        return this.customUsername;
      }

      // å…¶æ¬¡ä½¿ç”¨è‡ªåŠ¨æ£€æµ‹çš„ç”¨æˆ·å
      if (!this.currentUsername) {
        this.currentUsername = this.getCurrentUsername();
      }

      return this.currentUsername;
    }

    resetPosition() {
      // é‡ç½®åˆ°é»˜è®¤ä½ç½®ï¼ˆå·¦ä¸Šè§’ï¼‰
      const defaultPosition = { top: '10px', left: '10px' };

      if (this.panel) {
        this.panel.style.top = defaultPosition.top;
        this.panel.style.left = defaultPosition.left;
        this.panel.style.right = 'auto';
        this.panel.style.bottom = 'auto';
      }

      // ä¿å­˜é‡ç½®åçš„ä½ç½®
      GM_setValue('upgradeProgressPosition', defaultPosition);
      this.logger.log('å‡çº§è¿›åº¦çª—å£ä½ç½®å·²é‡ç½®åˆ°å·¦ä¸Šè§’', 'success');
    }

    testApiConnection() {
      const username = this.getEffectiveUsername();
      if (!username) {
        alert('è¯·å…ˆè®¾ç½®ç”¨æˆ·å');
        return;
      }

      this.logger.log('å¼€å§‹æµ‹è¯•APIè¿æ¥...', 'action');

      // æµ‹è¯•åŸºæœ¬çš„ç”¨æˆ·ä¿¡æ¯API
      GM_xmlhttpRequest({
        method: 'GET',
        url: `https://www.nodeloc.com/u/${username}.json`,
        headers: {
          'Accept': 'application/json',
          'X-Requested-With': 'XMLHttpRequest',
          'Referer': window.location.href
        },
        onload: (response) => {
          console.log(`[API Test] ç”¨æˆ·ä¿¡æ¯APIå“åº”çŠ¶æ€: ${response.status}`);
          console.log(`[API Test] ç”¨æˆ·ä¿¡æ¯APIå“åº”å†…å®¹:`, response.responseText);

          if (response.status === 200) {
            try {
              const data = JSON.parse(response.responseText);
              if (data.user) {
                this.logger.log(`âœ… ç”¨æˆ·ä¿¡æ¯APIæ­£å¸¸ï¼Œç”¨æˆ·ID: ${data.user.id}`, 'success');

                // ç»§ç»­æµ‹è¯•å‡çº§è¿›åº¦API
                this.testUpgradeProgressApi(username);
              } else {
                this.logger.log('âŒ ç”¨æˆ·ä¿¡æ¯APIè¿”å›æ•°æ®å¼‚å¸¸', 'error');
              }
            } catch (e) {
              this.logger.log('âŒ ç”¨æˆ·ä¿¡æ¯APIæ•°æ®è§£æå¤±è´¥', 'error');
            }
          } else {
            this.logger.log(`âŒ ç”¨æˆ·ä¿¡æ¯APIè¯·æ±‚å¤±è´¥ (${response.status})`, 'error');
          }
        },
        onerror: (error) => {
          this.logger.log('âŒ ç”¨æˆ·ä¿¡æ¯APIç½‘ç»œé”™è¯¯', 'error');
          console.error('[API Test] ç”¨æˆ·ä¿¡æ¯APIç½‘ç»œé”™è¯¯:', error);
        }
      });
    }

    testUpgradeProgressApi(username) {
      GM_xmlhttpRequest({
        method: 'GET',
        url: `https://www.nodeloc.com/u/${username}/upgrade-progress.json`,
        headers: {
          'Accept': 'application/json, text/javascript, */*; q=0.01',
          'X-Requested-With': 'XMLHttpRequest',
          'Referer': window.location.href
        },
        onload: (response) => {
          console.log(`[API Test] å‡çº§è¿›åº¦APIå“åº”çŠ¶æ€: ${response.status}`);
          console.log(`[API Test] å‡çº§è¿›åº¦APIå“åº”å†…å®¹:`, response.responseText);

          if (response.status === 200) {
            try {
              const data = JSON.parse(response.responseText);
              console.log('[API Test] å‡çº§è¿›åº¦APIå®Œæ•´å“åº”:', JSON.stringify(data, null, 2));

              if (data) {
                if (data.next_level) {
                  const nextLevel = data.next_level;
                  const nextLevelKeys = Object.keys(nextLevel);
                  this.logger.log(`âœ… å‡çº§è¿›åº¦APIæ­£å¸¸ï¼Œnext_levelå­—æ®µ: ${nextLevelKeys.join(', ')}`, 'success');
                  console.log('[API Test] next_levelè¯¦ç»†æ•°æ®:', nextLevel);
                  console.log('[API Test] next_levelç±»å‹:', typeof nextLevel);

                  // åˆ†ænext_levelçš„å…·ä½“å†…å®¹
                  if (typeof nextLevel === 'object') {
                    Object.entries(nextLevel).forEach(([key, value]) => {
                      console.log(`[API Test] next_level.${key}:`, value, `(ç±»å‹: ${typeof value})`);
                    });
                  }
                } else {
                  const keys = Object.keys(data);
                  this.logger.log(`âš ï¸ å‡çº§è¿›åº¦APIæ— next_levelï¼Œå¯ç”¨å­—æ®µ: ${keys.join(', ')}`, 'warning');
                  console.log('[API Test] å¯ç”¨æ•°æ®å­—æ®µ:', keys);
                  console.log('[API Test] å®Œæ•´æ•°æ®:', data);
                }
              } else {
                this.logger.log('âŒ å‡çº§è¿›åº¦APIè¿”å›ç©ºæ•°æ®', 'error');
              }
            } catch (e) {
              this.logger.log('âŒ å‡çº§è¿›åº¦APIæ•°æ®è§£æå¤±è´¥', 'error');
              console.error('[API Test] è§£æé”™è¯¯:', e);
              console.error('[API Test] åŸå§‹å“åº”:', response.responseText);
            }
          } else if (response.status === 403) {
            this.logger.log('âŒ å‡çº§è¿›åº¦APIæƒé™ä¸è¶³ï¼Œå¯èƒ½éœ€è¦ç™»å½•', 'error');
          } else if (response.status === 404) {
            this.logger.log('âŒ å‡çº§è¿›åº¦APIä¸å­˜åœ¨æˆ–ç”¨æˆ·ä¸å­˜åœ¨', 'error');
          } else {
            this.logger.log(`âŒ å‡çº§è¿›åº¦APIè¯·æ±‚å¤±è´¥ (${response.status})`, 'error');
          }
        },
        onerror: (error) => {
          this.logger.log('âŒ å‡çº§è¿›åº¦APIç½‘ç»œé”™è¯¯', 'error');
          console.error('[API Test] å‡çº§è¿›åº¦APIç½‘ç»œé”™è¯¯:', error);
        }
      });
    }

    getCurrentUsername() {
      // æ–¹æ³•1: ä»ç”¨æˆ·èœå•æŒ‰é’®è·å–
      const userMenuButton = document.querySelector('.header-dropdown-toggle.current-user');
      if (userMenuButton) {
        const img = userMenuButton.querySelector('img');
        if (img && img.alt) {
          console.log(`[Username] ä»ç”¨æˆ·èœå•è·å–åˆ°ç”¨æˆ·å: ${img.alt}`);
          return img.alt;
        }
      }

      // æ–¹æ³•2: ä»ç”¨æˆ·é“¾æ¥è·å–
      const userLinks = document.querySelectorAll('a[href*="/u/"]');
      for (const userLink of userLinks) {
        const match = userLink.href.match(/\/u\/([^\/]+)/);
        if (match && match[1]) {
          console.log(`[Username] ä»ç”¨æˆ·é“¾æ¥è·å–åˆ°ç”¨æˆ·å: ${match[1]}`);
          return match[1];
        }
      }

      // æ–¹æ³•3: ä»å½“å‰é¡µé¢URLè·å–ï¼ˆå¦‚æœåœ¨ç”¨æˆ·é¡µé¢ï¼‰
      if (window.location.pathname.includes('/u/')) {
        const match = window.location.pathname.match(/\/u\/([^\/]+)/);
        if (match && match[1]) {
          console.log(`[Username] ä»URLè·å–åˆ°ç”¨æˆ·å: ${match[1]}`);
          return match[1];
        }
      }

      // æ–¹æ³•4: ä»é¡µé¢æ ‡é¢˜è·å–
      const titleMatch = document.title.match(/(.+?)\s*-\s*NodeLoc/);
      if (titleMatch && titleMatch[1] && !titleMatch[1].includes('NodeLoc')) {
        console.log(`[Username] ä»é¡µé¢æ ‡é¢˜è·å–åˆ°ç”¨æˆ·å: ${titleMatch[1]}`);
        return titleMatch[1];
      }

      // æ–¹æ³•5: ä»metaæ ‡ç­¾è·å–
      const metaUser = document.querySelector('meta[name="discourse-username"]');
      if (metaUser && metaUser.content) {
        console.log(`[Username] ä»metaæ ‡ç­¾è·å–åˆ°ç”¨æˆ·å: ${metaUser.content}`);
        return metaUser.content;
      }

      console.log('[Username] æ— æ³•è‡ªåŠ¨è·å–ç”¨æˆ·å');
      return null;
    }

    updateUpgradeProgress() {
      if (window.location.hostname !== 'www.nodeloc.com') {
        this.upgradeProgress = 'N/A (éNodeLocç«™ç‚¹)';
        this.updateContent();
        return;
      }

      const username = this.getEffectiveUsername();
      if (!username) {
        this.upgradeProgress = 'æœªè®¾ç½®ç”¨æˆ·å';
        this.updateContent();
        return;
      }

      this.upgradeProgress = 'è·å–ä¸­...';
      this.updateContent();

      console.log(`[Upgrade Progress] æ­£åœ¨è·å–ç”¨æˆ· ${username} çš„å‡çº§è¿›åº¦`);

      GM_xmlhttpRequest({
        method: 'GET',
        url: `https://www.nodeloc.com/u/${username}/upgrade-progress.json`,
        headers: {
          'Accept': 'application/json, text/javascript, */*; q=0.01',
          'X-Requested-With': 'XMLHttpRequest',
          'Referer': window.location.href
        },
        onload: (response) => {
          console.log(`[Upgrade Progress] å“åº”çŠ¶æ€: ${response.status}`);
          console.log(`[Upgrade Progress] å“åº”å†…å®¹:`, response.responseText);

          try {
            if (response.status === 200) {
              const data = JSON.parse(response.responseText);
              let progress = 'è·å–ä¸åˆ°ä¿¡æ¯';

              console.log(`[Upgrade Progress] è§£æçš„æ•°æ®:`, data);

              // æ£€æŸ¥æ•°æ®ç»“æ„
              if (data) {
                console.log(`[Upgrade Progress] å®Œæ•´æ•°æ®ç»“æ„:`, JSON.stringify(data, null, 2));

                // æ–¹æ¡ˆ1: æ£€æŸ¥å‡çº§è¿›åº¦æ•°æ®ï¼ˆåŸºäºçœŸå®çš„NodeLoc APIç»“æ„ï¼‰
                if (data.next_level !== undefined && data.next_level_name && data.met_count !== undefined && data.total_conditions !== undefined) {
                  // NodeLocçš„çœŸå®æ•°æ®ç»“æ„
                  const nextLevelName = data.next_level_name;
                  const metCount = data.met_count;
                  const totalConditions = data.total_conditions;
                  const percentage = Math.round((metCount / totalConditions) * 100);

                  progress = `${nextLevelName} ${percentage}% (${metCount}/${totalConditions})`;

                  // ä¿å­˜æœªå®Œæˆæ¡ä»¶
                  if (data.unmet_conditions && Array.isArray(data.unmet_conditions)) {
                    this.unmetConditions = data.unmet_conditions;
                  } else {
                    this.unmetConditions = null;
                  }

                  console.log(`[Upgrade Progress] è§£ææˆåŠŸ: ${progress}`);
                }
                // æ–¹æ¡ˆ2: å¦‚æœæœ‰next_levelä½†ç»“æ„ä¸åŒ
                else if (data.next_level) {
                  const nextLevel = data.next_level;
                  console.log(`[Upgrade Progress] next_levelè¯¦ç»†ä¿¡æ¯:`, nextLevel);
                  console.log(`[Upgrade Progress] next_levelç±»å‹:`, typeof nextLevel);

                  if (typeof nextLevel === 'number') {
                    // next_levelæ˜¯æ•°å­—ï¼ŒæŸ¥æ‰¾ç­‰çº§åç§°
                    if (data.next_level_name) {
                      progress = `ä¸‹ä¸€ç­‰çº§: ${data.next_level_name} (ç­‰çº§${nextLevel})`;
                    } else {
                      const levelNames = ['æ–°æ‰‹', 'åŸºç¡€ä¼šå‘˜', 'ä¼šå‘˜', 'èµ„æ·±ä¼šå‘˜', 'é’»çŸ³ä¼šå‘˜', 'é¢†å¯¼è€…'];
                      progress = `ä¸‹ä¸€ç­‰çº§: ${levelNames[nextLevel] || `ç­‰çº§${nextLevel}`}`;
                    }
                  }
                  else if (typeof nextLevel === 'object') {
                    // æ£€æŸ¥å„ç§å¯èƒ½çš„å­—æ®µç»„åˆ
                    if (nextLevel.name && nextLevel.progress !== undefined && nextLevel.total !== undefined) {
                      const percentage = Math.round((nextLevel.progress / nextLevel.total) * 100);
                      progress = `${nextLevel.name} ${percentage}%`;
                    }
                    else if (nextLevel.name && nextLevel.current !== undefined && nextLevel.required !== undefined) {
                      const percentage = Math.round((nextLevel.current / nextLevel.required) * 100);
                      progress = `${nextLevel.name} ${percentage}%`;
                    }
                    else if (nextLevel.name) {
                      progress = `ä¸‹ä¸€ç­‰çº§: ${nextLevel.name}`;
                    }
                    else {
                      // æ˜¾ç¤ºå¯¹è±¡çš„æ‰€æœ‰é”®å€¼å¯¹
                      const entries = Object.entries(nextLevel).map(([key, value]) => `${key}: ${value}`);
                      progress = `next_level: {${entries.join(', ')}}`;
                    }
                  }
                  else if (typeof nextLevel === 'string') {
                    progress = `ä¸‹ä¸€ç­‰çº§: ${nextLevel}`;
                  }
                  else {
                    progress = `next_level: ${JSON.stringify(nextLevel)}`;
                  }
                }
                // æ–¹æ¡ˆ2: æ£€æŸ¥ç”¨æˆ·ä¿¡ä»»ç­‰çº§
                else if (data.user && data.user.trust_level !== undefined) {
                  const trustLevel = data.user.trust_level;
                  const levelNames = ['æ–°æ‰‹', 'åŸºç¡€ä¼šå‘˜', 'ä¼šå‘˜', 'èµ„æ·±ä¼šå‘˜', 'é¢†å¯¼è€…'];
                  progress = `ä¿¡ä»»ç­‰çº§ ${trustLevel} (${levelNames[trustLevel] || 'æœªçŸ¥'})`;
                }
                // æ–¹æ¡ˆ3: æ£€æŸ¥å…¶ä»–å¯èƒ½çš„æ•°æ®ç»“æ„
                else if (data.upgrade_progress) {
                  progress = `è¿›åº¦: ${JSON.stringify(data.upgrade_progress)}`;
                }
                else if (data.level_info) {
                  progress = `ç­‰çº§ä¿¡æ¯: ${JSON.stringify(data.level_info)}`;
                }
                else if (data.progress) {
                  progress = `è¿›åº¦: ${JSON.stringify(data.progress)}`;
                }
                // æ–¹æ¡ˆ4: æ˜¾ç¤ºæ‰€æœ‰å¯ç”¨çš„é”®
                else {
                  const keys = Object.keys(data);
                  progress = `å¯ç”¨å­—æ®µ: ${keys.join(', ')}`;
                  console.warn('[Upgrade Progress] æœªè¯†åˆ«çš„æ•°æ®ç»“æ„ï¼Œå¯ç”¨å­—æ®µ:', keys);
                  console.warn('[Upgrade Progress] å®Œæ•´æ•°æ®:', data);
                }
              } else {
                progress = 'æ•°æ®ä¸ºç©º';
              }

              this.upgradeProgress = progress;
            } else if (response.status === 403) {
              this.upgradeProgress = 'æƒé™ä¸è¶³';
            } else if (response.status === 404) {
              this.upgradeProgress = 'ç”¨æˆ·ä¸å­˜åœ¨';
            } else {
              this.upgradeProgress = `è¯·æ±‚å¤±è´¥ (${response.status})`;
            }

            this.updateContent();
          } catch (e) {
            this.upgradeProgress = 'æ•°æ®è§£æé”™è¯¯';
            this.updateContent();
            console.error('[Upgrade Progress] è§£æé”™è¯¯:', e);
            console.error('[Upgrade Progress] åŸå§‹å“åº”:', response.responseText);
          }
        },
        onerror: (error) => {
          this.upgradeProgress = 'ç½‘ç»œè¯·æ±‚å¤±è´¥';
          this.updateContent();
          console.error('[Upgrade Progress] ç½‘ç»œé”™è¯¯:', error);
        },
        ontimeout: () => {
          this.upgradeProgress = 'è¯·æ±‚è¶…æ—¶';
          this.updateContent();
          console.error('[Upgrade Progress] è¯·æ±‚è¶…æ—¶');
        },
        timeout: 10000 // 10ç§’è¶…æ—¶
      });
    }

    show() {
      if (!this.panel) this.create();
      this.panel.style.display = 'flex';
      this.isVisible = true;

      // ä¿å­˜æ˜¾ç¤ºçŠ¶æ€
      GM_setValue('upgradeProgressVisible', true);

      // ç«‹å³æ›´æ–°ä¸€æ¬¡
      this.updateContent();
      this.updateUpgradeProgress();

      // è®¾ç½®å®šæ—¶å™¨
      if (this.updateInterval) clearInterval(this.updateInterval);
      this.updateInterval = setInterval(() => {
        this.updateUpgradeProgress();
      }, 10000); // 10ç§’åˆ·æ–°ä¸€æ¬¡
    }

    hide() {
      if (this.panel) this.panel.style.display = 'none';
      this.isVisible = false;

      // ä¿å­˜éšè—çŠ¶æ€
      GM_setValue('upgradeProgressVisible', false);

      // åœæ­¢æ›´æ–°
      if (this.updateInterval) {
        clearInterval(this.updateInterval);
        this.updateInterval = null;
      }
    }

    toggle() {
      if (this.isVisible) {
        this.hide();
      } else {
        this.show();
      }
    }
  }

  // ===== æ§åˆ¶é¢æ¿ç±» =====
  class ControlPanel {
    constructor(config, logger, statsPanel, configPanel, upgradePanel) {
      this.config = config;
      this.logger = logger;
      this.statsPanel = statsPanel;
      this.configPanel = configPanel;
      this.upgradePanel = upgradePanel;
      this.panel = null;
      this.buttons = {};
    }

    create() {
      if (this.panel) return;

      const isDark = this.config.get('theme') === 'dark';

      this.panel = document.createElement('div');
      this.panel.id = 'forum-assistant-controls';
      Object.assign(this.panel.style, {
        position: 'fixed',
        bottom: '10px',
        right: '10px',
        display: 'flex',
        flexDirection: 'column',
        gap: '8px',
        zIndex: '9999'
      });

      // åˆ›å»ºæ§åˆ¶æŒ‰é’®
      this.createControlButtons();

      document.body.appendChild(this.panel);
    }

    createControlButtons() {
      const buttons = [
        { id: 'toggle-reading', text: 'å¼€å§‹é˜…è¯»', icon: 'ğŸ“–', action: () => this.toggleReading() },
        { id: 'toggle-like', text: 'å¯ç”¨ç‚¹èµ', icon: 'ğŸ‘', action: () => this.toggleAutoLike() },
        { id: 'show-stats', text: 'æ˜¾ç¤ºç»Ÿè®¡', icon: 'ğŸ“Š', action: () => this.statsPanel.toggle() },
        { id: 'show-upgrade', text: 'å‡çº§è¿›åº¦', icon: 'ğŸ“ˆ', action: () => this.toggleUpgradeProgress() },
        { id: 'show-config', text: 'æ‰“å¼€è®¾ç½®', icon: 'âš™ï¸', action: () => this.configPanel.toggle() },
        { id: 'show-logs', text: 'æ˜¾ç¤ºæ—¥å¿—', icon: 'ğŸ“‹', action: () => this.logger.toggleVisibility() }
      ];

      buttons.forEach(btn => {
        const button = this.createButton(btn);
        this.buttons[btn.id] = button;
        this.panel.appendChild(button);
      });

      this.updateButtonStates();
    }

    createButton(config) {
      const isDark = this.config.get('theme') === 'dark';

      const button = document.createElement('button');
      button.innerHTML = `${config.icon} ${config.text}`;
      Object.assign(button.style, {
        padding: '10px 15px',
        backgroundColor: isDark ? '#4a5568' : '#ffffff',
        color: isDark ? '#e2e8f0' : '#2d3748',
        border: `1px solid ${isDark ? '#718096' : '#d1d5db'}`,
        borderRadius: '8px',
        cursor: 'pointer',
        fontSize: '13px',
        fontWeight: '500',
        display: 'flex',
        alignItems: 'center',
        gap: '6px',
        minWidth: '120px',
        justifyContent: 'flex-start',
        transition: 'all 0.2s ease',
        boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
      });

      button.addEventListener('click', config.action);

      // æ‚¬åœæ•ˆæœ
      button.addEventListener('mouseenter', () => {
        button.style.transform = 'translateY(-1px)';
        button.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
      });

      button.addEventListener('mouseleave', () => {
        button.style.transform = 'translateY(0)';
        button.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
      });

      return button;
    }

    toggleReading() {
      const isReading = GM_getValue('isReading', false);
      GM_setValue('isReading', !isReading);

      this.updateButtonStates();

      if (!isReading) {
        this.logger.log('å¼€å§‹è‡ªåŠ¨é˜…è¯»', 'action');
        // è°ƒç”¨ä¸»ç¨‹åºçš„å¼€å§‹é˜…è¯»é€»è¾‘
        if (window.forumAssistant && typeof window.forumAssistant.start === 'function') {
          window.forumAssistant.start();
        }
      } else {
        this.logger.log('åœæ­¢è‡ªåŠ¨é˜…è¯»', 'action');
        // è°ƒç”¨ä¸»ç¨‹åºçš„åœæ­¢é˜…è¯»é€»è¾‘
        if (window.forumAssistant && typeof window.forumAssistant.stop === 'function') {
          window.forumAssistant.stop();
        }
      }
    }

    toggleAutoLike() {
      const rateLimitInfo = GM_getValue('rateLimitInfo', null);

      // æ£€æŸ¥æ˜¯å¦ä»åœ¨é™åˆ¶æœŸå†…
      if (rateLimitInfo && this.isRateLimitActive(rateLimitInfo)) {
        const remainingTime = this.getRemainingTime(rateLimitInfo);
        const canLikeTime = this.getCanLikeTime(rateLimitInfo);

        this.logger.log(`ç‚¹èµä»åœ¨é™åˆ¶æœŸå†…ï¼Œå‰©ä½™æ—¶é—´: ${remainingTime}`, 'warning');
        this.logger.log(`ğŸ“… é¢„è®¡å¯ç‚¹èµæ—¶é—´: ${canLikeTime}`, 'info');
        this.logger.showNotification(`ç‚¹èµå—é™ï¼Œå‰©ä½™æ—¶é—´: ${remainingTime}`, 'warning');
        return;
      }

      // å¦‚æœé™åˆ¶å·²è¿‡æœŸï¼Œæ¸…é™¤é™åˆ¶ä¿¡æ¯
      if (rateLimitInfo && !this.isRateLimitActive(rateLimitInfo)) {
        GM_setValue('rateLimitInfo', null);
        this.logger.log('ç‚¹èµé™åˆ¶å·²è¿‡æœŸï¼Œå·²æ¸…é™¤é™åˆ¶ä¿¡æ¯', 'success');
      }

      const isEnabled = GM_getValue('autoLikeEnabled', false);
      const newState = !isEnabled;
      GM_setValue('autoLikeEnabled', newState);

      this.updateButtonStates();

      if (newState) {
        // å¯ç”¨æ—¶æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
        this.logger.log(`ğŸ¯ è‡ªåŠ¨ç‚¹èµå·²å¯ç”¨`, 'success');
        this.showLikeStatusInfo();
      } else {
        this.logger.log(`â¸ï¸ è‡ªåŠ¨ç‚¹èµå·²ç¦ç”¨`, 'action');
      }
    }

    // æ˜¾ç¤ºç‚¹èµçŠ¶æ€ä¿¡æ¯
    showLikeStatusInfo() {
      const rateLimitInfo = GM_getValue('rateLimitInfo', null);

      if (rateLimitInfo && this.isRateLimitActive(rateLimitInfo)) {
        // ä»åœ¨é™åˆ¶æœŸå†…
        const remainingTime = this.getRemainingTime(rateLimitInfo);
        const canLikeTime = this.getCanLikeTime(rateLimitInfo);

        this.logger.log(`âš ï¸ å½“å‰çŠ¶æ€: ç‚¹èµå—é™`, 'warning');
        this.logger.log(`â° å‰©ä½™ç­‰å¾…æ—¶é—´: ${remainingTime}`, 'warning');
        this.logger.log(`ğŸ“… é¢„è®¡å¯ç‚¹èµæ—¶é—´: ${canLikeTime}`, 'info');
        this.logger.log(`ğŸ’¡ é™åˆ¶åŸå› : ${rateLimitInfo.message || 'æœªçŸ¥'}`, 'info');
      } else {
        // å¯ä»¥æ­£å¸¸ç‚¹èµ
        const currentTime = new Date().toLocaleString('zh-CN');
        this.logger.log(`âœ… å½“å‰çŠ¶æ€: å¯ä»¥æ­£å¸¸ç‚¹èµ`, 'success');
        this.logger.log(`ğŸ• å½“å‰æ—¶é—´: ${currentTime}`, 'info');

        // æ˜¾ç¤ºä»Šæ—¥ç‚¹èµç»Ÿè®¡
        const dailyLikeCount = GM_getValue('dailyLikeCount', 0);
        const maxLikes = this.siteAdapter?.getLimit('maxLikes') || 100;
        this.logger.log(`ğŸ“Š ä»Šæ—¥ç‚¹èµ: ${dailyLikeCount}/${maxLikes}`, 'info');

        if (dailyLikeCount >= maxLikes) {
          this.logger.log(`âš ï¸ ä»Šæ—¥ç‚¹èµå·²è¾¾ä¸Šé™`, 'warning');
        } else {
          const remaining = maxLikes - dailyLikeCount;
          this.logger.log(`ğŸ’ª å‰©ä½™å¯ç‚¹èµ: ${remaining} æ¬¡`, 'success');
        }
      }
    }

    // è·å–å¯ä»¥ç‚¹èµçš„å…·ä½“æ—¶é—´
    getCanLikeTime(rateLimitInfo) {
      if (!rateLimitInfo || !rateLimitInfo.waitSeconds || !rateLimitInfo.timestamp) {
        return 'æœªçŸ¥';
      }

      const canLikeTimestamp = rateLimitInfo.timestamp + (rateLimitInfo.waitSeconds * 1000);
      const canLikeDate = new Date(canLikeTimestamp);

      return canLikeDate.toLocaleString('zh-CN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
    }

    // è·å–å‰©ä½™é™åˆ¶æ—¶é—´
    getRemainingTime(rateLimitInfo) {
      if (!rateLimitInfo || !rateLimitInfo.waitSeconds || !rateLimitInfo.timestamp) {
        return 'æœªçŸ¥';
      }

      const now = Date.now();
      const limitEndTime = rateLimitInfo.timestamp + (rateLimitInfo.waitSeconds * 1000);
      const remainingMs = limitEndTime - now;

      if (remainingMs <= 0) {
        return 'å·²è¿‡æœŸ';
      }

      const hours = Math.floor(remainingMs / (1000 * 60 * 60));
      const minutes = Math.floor((remainingMs % (1000 * 60 * 60)) / (1000 * 60));

      if (hours > 0) {
        return `${hours}å°æ—¶${minutes}åˆ†é’Ÿ`;
      } else {
        return `${minutes}åˆ†é’Ÿ`;
      }
    }

    toggleUpgradeProgress() {
      this.upgradePanel.toggle();
      this.updateButtonStates();
      this.logger.log(`å‡çº§è¿›åº¦é¢æ¿å·²${this.upgradePanel.isVisible ? 'æ˜¾ç¤º' : 'éšè—'}`, 'action');
    }

    updateButtonStates() {
      const isReading = GM_getValue('isReading', false);
      const isLikeEnabled = GM_getValue('autoLikeEnabled', false);
      const isUpgradeVisible = this.upgradePanel.isVisible;
      const rateLimitInfo = GM_getValue('rateLimitInfo', null);

      if (this.buttons && this.buttons['toggle-reading']) {
        const btn = this.buttons['toggle-reading'];
        if (btn) {
          btn.innerHTML = `ğŸ“– ${isReading ? 'åœæ­¢é˜…è¯»' : 'å¼€å§‹é˜…è¯»'}`;
          btn.style.backgroundColor = isReading ? '#dc3545' : (this.config.get('theme') === 'dark' ? '#4a5568' : '#ffffff');
          btn.style.color = isReading ? '#ffffff' : (this.config.get('theme') === 'dark' ? '#e2e8f0' : '#2d3748');
        }
      }

      if (this.buttons && this.buttons['toggle-like']) {
        const btn = this.buttons['toggle-like'];
        if (btn) {
          // æ£€æŸ¥æ˜¯å¦æœ‰é™åˆ¶ä¿¡æ¯
          if (rateLimitInfo && this.isRateLimitActive(rateLimitInfo)) {
            btn.innerHTML = `ğŸš« ç‚¹èµå—é™`;
            btn.style.backgroundColor = '#dc3545';
            btn.style.color = '#ffffff';
            btn.title = `ç‚¹èµå·²è¾¾é™åˆ¶ï¼Œå‰©ä½™ç­‰å¾…æ—¶é—´: ${rateLimitInfo.timeLeft}`;
          } else {
            btn.innerHTML = `ğŸ‘ ${isLikeEnabled ? 'ç¦ç”¨ç‚¹èµ' : 'å¯ç”¨ç‚¹èµ'}`;
            btn.style.backgroundColor = isLikeEnabled ? '#28a745' : (this.config.get('theme') === 'dark' ? '#4a5568' : '#ffffff');
            btn.style.color = isLikeEnabled ? '#ffffff' : (this.config.get('theme') === 'dark' ? '#e2e8f0' : '#2d3748');
            btn.title = isLikeEnabled ? 'ç‚¹å‡»ç¦ç”¨è‡ªåŠ¨ç‚¹èµ' : 'ç‚¹å‡»å¯ç”¨è‡ªåŠ¨ç‚¹èµ';
          }
        }
      }

      if (this.buttons && this.buttons['show-upgrade']) {
        const btn = this.buttons['show-upgrade'];
        if (btn) {
          btn.innerHTML = `ğŸ“ˆ ${isUpgradeVisible ? 'éšè—è¿›åº¦' : 'å‡çº§è¿›åº¦'}`;
          btn.style.backgroundColor = isUpgradeVisible ? '#8b5cf6' : (this.config.get('theme') === 'dark' ? '#4a5568' : '#ffffff');
          btn.style.color = isUpgradeVisible ? '#ffffff' : (this.config.get('theme') === 'dark' ? '#e2e8f0' : '#2d3748');
        }
      }
    }

    // æ£€æŸ¥é™åˆ¶æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
    isRateLimitActive(rateLimitInfo) {
      if (!rateLimitInfo || !rateLimitInfo.waitSeconds || !rateLimitInfo.timestamp) {
        return false;
      }

      const now = Date.now();
      const limitEndTime = rateLimitInfo.timestamp + (rateLimitInfo.waitSeconds * 1000);

      return now < limitEndTime;
    }

    show() {
      if (!this.panel) this.create();
      this.panel.style.display = 'flex';
    }

    hide() {
      if (this.panel) this.panel.style.display = 'none';
    }
  }

  // ===== çŠ¶æ€æŒ‡ç¤ºå™¨ç±» =====
  class StatusIndicator {
    constructor(config, logger) {
      this.config = config;
      this.logger = logger;
      this.indicator = null;
      this.statusText = null;
      this.progressBar = null;
    }

    create() {
      if (this.indicator) return;

      const isDark = this.config.get('theme') === 'dark';

      this.indicator = document.createElement('div');
      this.indicator.id = 'forum-assistant-status';
      Object.assign(this.indicator.style, {
        position: 'fixed',
        top: '10px',
        left: '50%',
        transform: 'translateX(-50%)',
        backgroundColor: isDark ? '#2d3748' : '#ffffff',
        color: isDark ? '#e2e8f0' : '#2d3748',
        border: `1px solid ${isDark ? '#4a5568' : '#e2e8f0'}`,
        borderRadius: '20px',
        padding: '8px 16px',
        fontSize: '12px',
        fontWeight: '500',
        zIndex: '9998',
        display: 'none',
        alignItems: 'center',
        gap: '8px',
        boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
        backdropFilter: 'blur(10px)',
        minWidth: '200px',
        justifyContent: 'center'
      });

      // çŠ¶æ€å›¾æ ‡
      this.statusIcon = document.createElement('span');
      this.statusIcon.textContent = 'â¸ï¸';

      // çŠ¶æ€æ–‡æœ¬
      this.statusText = document.createElement('span');
      this.statusText.textContent = 'å¾…æœºä¸­';

      // è¿›åº¦æ¡å®¹å™¨
      const progressContainer = document.createElement('div');
      Object.assign(progressContainer.style, {
        width: '60px',
        height: '4px',
        backgroundColor: isDark ? '#4a5568' : '#e2e8f0',
        borderRadius: '2px',
        overflow: 'hidden'
      });

      // è¿›åº¦æ¡
      this.progressBar = document.createElement('div');
      Object.assign(this.progressBar.style, {
        width: '0%',
        height: '100%',
        backgroundColor: '#3182ce',
        borderRadius: '2px',
        transition: 'width 0.3s ease'
      });

      progressContainer.appendChild(this.progressBar);

      this.indicator.appendChild(this.statusIcon);
      this.indicator.appendChild(this.statusText);
      this.indicator.appendChild(progressContainer);

      document.body.appendChild(this.indicator);
    }

    updateStatus(status, progress = 0) {
      if (!this.indicator) this.create();

      const statusConfig = {
        idle: { icon: 'â¸ï¸', text: 'å¾…æœºä¸­', color: '#6b7280' },
        reading: { icon: 'ğŸ“–', text: 'é˜…è¯»ä¸­', color: '#3182ce' },
        scrolling: { icon: 'ğŸ”„', text: 'æ»šåŠ¨ä¸­', color: '#10b981' },
        liking: { icon: 'ğŸ‘', text: 'ç‚¹èµä¸­', color: '#f59e0b' },
        switching: { icon: 'ğŸ”€', text: 'åˆ‡æ¢è¯é¢˜', color: '#8b5cf6' },
        error: { icon: 'âŒ', text: 'å‡ºç°é”™è¯¯', color: '#dc3545' },
        loading: { icon: 'â³', text: 'åŠ è½½ä¸­', color: '#6366f1' }
      };

      const config = statusConfig[status] || statusConfig.idle;

      if (this.statusIcon) this.statusIcon.textContent = config.icon;
      if (this.statusText) this.statusText.textContent = config.text;
      if (this.progressBar) {
        this.progressBar.style.backgroundColor = config.color;
        this.progressBar.style.width = `${Math.max(0, Math.min(100, progress))}%`;
      }

      // è‡ªåŠ¨æ˜¾ç¤º/éšè—
      if (status !== 'idle') {
        this.show();
      } else {
        setTimeout(() => this.hide(), 2000);
      }
    }

    show() {
      if (!this.indicator) this.create();
      this.indicator.style.display = 'flex';
    }

    hide() {
      if (this.indicator) this.indicator.style.display = 'none';
    }
  }

  // ===== æ™ºèƒ½è¡Œä¸ºæ¨¡æ‹Ÿç±» =====
  class BehaviorSimulator {
    constructor(config, logger, statusIndicator) {
      this.config = config;
      this.logger = logger;
      this.statusIndicator = statusIndicator;
      this.mouseTracker = null;
      this.behaviorQueue = [];
      this.isSimulating = false;
    }

    // é¼ æ ‡ç§»åŠ¨æ¨¡æ‹Ÿ
    simulateMouseMovement() {
      if (!this.config.get('enableMouseSimulation')) return;

      const startX = Math.random() * window.innerWidth;
      const startY = Math.random() * window.innerHeight;
      const endX = Math.random() * window.innerWidth;
      const endY = Math.random() * window.innerHeight;

      const duration = Utils.getRandomInt(1000, 3000);
      const steps = 30;
      const stepDuration = duration / steps;

      let currentStep = 0;
      const moveInterval = setInterval(() => {
        if (currentStep >= steps) {
          clearInterval(moveInterval);
          return;
        }

        const progress = currentStep / steps;
        const easeProgress = this.easeInOutCubic(progress);

        const currentX = startX + (endX - startX) * easeProgress;
        const currentY = startY + (endY - startY) * easeProgress;

        // åˆ›å»ºé¼ æ ‡ç§»åŠ¨äº‹ä»¶
        const event = new MouseEvent('mousemove', {
          clientX: currentX,
          clientY: currentY,
          bubbles: true
        });
        document.dispatchEvent(event);

        currentStep++;
      }, stepDuration);
    }

    // éšæœºé¡µé¢äº¤äº’
    async simulatePageInteraction() {
      if (!this.config.get('enableAdvancedBehavior')) return;

      const interactions = [
        () => this.simulateTextSelection(),
        () => this.simulateScrollPause(),
        () => this.simulateElementHover(),
        () => this.simulateKeyboardActivity(),
        () => this.simulateWindowResize()
      ];

      const randomInteraction = interactions[Math.floor(Math.random() * interactions.length)];
      await randomInteraction();
    }

    // æ–‡æœ¬é€‰æ‹©æ¨¡æ‹Ÿ
    simulateTextSelection() {
      const textElements = document.querySelectorAll('p, div, span, h1, h2, h3, h4, h5, h6');
      if (textElements.length === 0) return;

      const randomElement = textElements[Math.floor(Math.random() * textElements.length)];
      const text = randomElement.textContent;

      if (text.length > 10) {
        const startIndex = Math.floor(Math.random() * (text.length - 10));
        const endIndex = startIndex + Utils.getRandomInt(5, 20);

        try {
          const range = document.createRange();
          const textNode = randomElement.firstChild;
          if (textNode && textNode.nodeType === Node.TEXT_NODE) {
            range.setStart(textNode, Math.min(startIndex, textNode.textContent.length));
            range.setEnd(textNode, Math.min(endIndex, textNode.textContent.length));

            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);

            // çŸ­æš‚ä¿æŒé€‰æ‹©çŠ¶æ€
            setTimeout(() => {
              selection.removeAllRanges();
            }, Utils.getRandomInt(500, 2000));

            this.logger.log('æ¨¡æ‹Ÿæ–‡æœ¬é€‰æ‹©', 'action');
          }
        } catch (e) {
          // å¿½ç•¥é€‰æ‹©é”™è¯¯
        }
      }
    }

    // æ»šåŠ¨æš‚åœæ¨¡æ‹Ÿ
    async simulateScrollPause() {
      const pauseDuration = Utils.getRandomInt(1000, 5000);
      this.statusIndicator.updateStatus('reading', 50);

      await Utils.sleep(pauseDuration);
      this.logger.log(`æ¨¡æ‹Ÿé˜…è¯»æš‚åœ ${pauseDuration}ms`, 'action');
    }

    // å…ƒç´ æ‚¬åœæ¨¡æ‹Ÿ
    simulateElementHover() {
      const hoverableElements = document.querySelectorAll('a, button, .btn, [role="button"]');
      if (hoverableElements.length === 0) return;

      const randomElement = hoverableElements[Math.floor(Math.random() * hoverableElements.length)];

      // è§¦å‘æ‚¬åœäº‹ä»¶
      const mouseEnter = new MouseEvent('mouseenter', { bubbles: true });
      const mouseOver = new MouseEvent('mouseover', { bubbles: true });

      randomElement.dispatchEvent(mouseEnter);
      randomElement.dispatchEvent(mouseOver);

      // çŸ­æš‚æ‚¬åœåç§»å¼€
      setTimeout(() => {
        const mouseLeave = new MouseEvent('mouseleave', { bubbles: true });
        const mouseOut = new MouseEvent('mouseout', { bubbles: true });

        randomElement.dispatchEvent(mouseLeave);
        randomElement.dispatchEvent(mouseOut);
      }, Utils.getRandomInt(500, 2000));

      this.logger.log('æ¨¡æ‹Ÿå…ƒç´ æ‚¬åœ', 'action');
    }

    // é”®ç›˜æ´»åŠ¨æ¨¡æ‹Ÿ
    simulateKeyboardActivity() {
      const keys = ['ArrowDown', 'ArrowUp', 'PageDown', 'PageUp', 'Home', 'End'];
      const randomKey = keys[Math.floor(Math.random() * keys.length)];

      const keyEvent = new KeyboardEvent('keydown', {
        key: randomKey,
        code: randomKey,
        bubbles: true
      });

      document.dispatchEvent(keyEvent);
      this.logger.log(`æ¨¡æ‹ŸæŒ‰é”®: ${randomKey}`, 'action');
    }

    // çª—å£å¤§å°è°ƒæ•´æ¨¡æ‹Ÿ
    simulateWindowResize() {
      // æ¨¡æ‹Ÿçª—å£å¤§å°å˜åŒ–äº‹ä»¶
      const resizeEvent = new Event('resize');
      window.dispatchEvent(resizeEvent);
      this.logger.log('æ¨¡æ‹Ÿçª—å£è°ƒæ•´', 'action');
    }

    // éšæœºè¡Œä¸ºè§¦å‘
    async triggerRandomBehavior() {
      if (!this.isSimulating) return;

      const behaviors = [
        { action: () => this.simulateMouseMovement(), weight: 3 },
        { action: () => this.simulatePageInteraction(), weight: 2 },
        { action: () => this.simulateScrollPause(), weight: 1 }
      ];

      // æƒé‡éšæœºé€‰æ‹©
      const totalWeight = behaviors.reduce((sum, b) => sum + b.weight, 0);
      let random = Math.random() * totalWeight;

      for (const behavior of behaviors) {
        random -= behavior.weight;
        if (random <= 0) {
          await behavior.action();
          break;
        }
      }

      // éšæœºé—´éš”åå†æ¬¡è§¦å‘
      const nextDelay = Utils.getRandomInt(5000, 15000);
      setTimeout(() => this.triggerRandomBehavior(), nextDelay);
    }

    // ç¼“åŠ¨å‡½æ•°
    easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    // å¼€å§‹è¡Œä¸ºæ¨¡æ‹Ÿ
    start() {
      if (this.isSimulating) return;

      this.isSimulating = true;
      this.logger.log('å¼€å§‹æ™ºèƒ½è¡Œä¸ºæ¨¡æ‹Ÿ', 'action');

      // å¯åŠ¨éšæœºè¡Œä¸º
      setTimeout(() => this.triggerRandomBehavior(), Utils.getRandomInt(2000, 5000));
    }

    // åœæ­¢è¡Œä¸ºæ¨¡æ‹Ÿ
    stop() {
      this.isSimulating = false;
      this.logger.log('åœæ­¢æ™ºèƒ½è¡Œä¸ºæ¨¡æ‹Ÿ', 'action');
    }
  }

  // ===== å¢å¼ºæ»šåŠ¨ç³»ç»Ÿç±» =====
  class EnhancedScrollSystem {
    constructor(config, logger, statusIndicator, behaviorSimulator) {
      this.config = config;
      this.logger = logger;
      this.statusIndicator = statusIndicator;
      this.behaviorSimulator = behaviorSimulator;

      this.scrollInterval = null;
      this.checkScrollTimeout = null;
      this.lastScrollY = 0;
      this.scrollDirection = 'down';
      this.isScrolling = false;
      this.scrollStartTime = 0;
    }

    // è´å¡å°”æ›²çº¿åˆ†æ®µæ»šåŠ¨ (å‘ä¸‹)
    async scrollWithBezier() {
      if (this.scrollInterval !== null) {
        clearInterval(this.scrollInterval);
      }

      const startY = window.scrollY;
      const documentHeight = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
      const windowHeight = window.innerHeight;
      const pageBottom = documentHeight - windowHeight;

      // æ£€æŸ¥æ˜¯å¦å·²æ¥è¿‘åº•éƒ¨
      if (startY >= pageBottom - 10) {
        this.logger.log("å·²æ¥è¿‘é¡µé¢åº•éƒ¨ï¼Œåœæ­¢å‘ä¸‹æ»šåŠ¨", 'info');
        this.statusIndicator.updateStatus('idle');
        return false;
      }

      this.isScrolling = true;
      this.scrollStartTime = Date.now();
      this.statusIndicator.updateStatus('scrolling', 0);

      // è®¡ç®—æ»šåŠ¨å‚æ•°
      const segmentDistance = Utils.getRandomInt(
        this.config.get('scrollSegmentDistanceMin'),
        this.config.get('scrollSegmentDistanceMax')
      );
      const targetY = Math.min(startY + segmentDistance, pageBottom);
      const totalDuration = Utils.getRandomInt(
        this.config.get('scrollSegmentDurationMin'),
        this.config.get('scrollSegmentDurationMax')
      );
      const steps = Math.max(20, Math.round(totalDuration / 50));
      const stepDuration = totalDuration / steps;

      // éšæœºè´å¡å°”æ§åˆ¶ç‚¹
      const p0 = 0, p3 = 1;
      const p1 = Utils.getRandomFloat(this.config.get('bezierP1Min'), this.config.get('bezierP1Max'));
      const p2 = Utils.getRandomFloat(this.config.get('bezierP2Min'), this.config.get('bezierP2Max'));

      this.logger.log(`å‘ä¸‹æ»šåŠ¨: ${Math.round(startY)} â†’ ${Math.round(targetY)} (${Math.round(targetY - startY)}px, ${totalDuration}ms)`, 'action');

      let currentStep = 0;

      return new Promise((resolve) => {
        this.scrollInterval = setInterval(async () => {
          if (currentStep >= steps) {
            clearInterval(this.scrollInterval);
            this.scrollInterval = null;
            this.isScrolling = false;

            window.scrollTo(0, targetY);
            this.statusIndicator.updateStatus('idle');
            this.logger.log("å‘ä¸‹æ»šåŠ¨å®Œæˆ", 'success');

            // éšæœºè§¦å‘è¡Œä¸ºæ¨¡æ‹Ÿ
            if (Math.random() < 0.3) {
              await this.behaviorSimulator.simulatePageInteraction();
            }

            resolve(true);
            return;
          }

          const t = currentStep / steps;
          const progress = Utils.cubicBezier(t, p0, p1, p2, p3);
          const scrollPosition = startY + (targetY - startY) * progress;

          window.scrollTo(0, scrollPosition);

          // æ›´æ–°è¿›åº¦
          const scrollProgress = (currentStep / steps) * 100;
          this.statusIndicator.updateStatus('scrolling', scrollProgress);

          currentStep++;

          // éšæœºæš‚åœ
          if (Math.random() < this.config.get('randomPauseProbability')) {
            const pauseDuration = Utils.getRandomInt(
              this.config.get('randomPauseDurationMin'),
              this.config.get('randomPauseDurationMax')
            );
            await Utils.sleep(pauseDuration);
          }
        }, stepDuration);
      });
    }

    // è´å¡å°”æ›²çº¿åˆ†æ®µæ»šåŠ¨ (å‘ä¸Š)
    async scrollUpWithBezier() {
      if (this.scrollInterval !== null) {
        clearInterval(this.scrollInterval);
      }

      const startY = window.scrollY;

      // æ£€æŸ¥æ˜¯å¦å·²æ¥è¿‘é¡¶éƒ¨
      if (startY <= 10) {
        this.logger.log("å·²æ¥è¿‘é¡µé¢é¡¶éƒ¨ï¼Œåœæ­¢å‘ä¸Šæ»šåŠ¨", 'info');
        this.statusIndicator.updateStatus('idle');
        return false;
      }

      this.isScrolling = true;
      this.scrollStartTime = Date.now();
      this.statusIndicator.updateStatus('scrolling', 0);

      // è®¡ç®—æ»šåŠ¨å‚æ•°
      const segmentDistance = Utils.getRandomInt(
        this.config.get('scrollSegmentDistanceMin'),
        this.config.get('scrollSegmentDistanceMax')
      );
      const targetY = Math.max(startY - segmentDistance, 0);
      const totalDuration = Utils.getRandomInt(
        this.config.get('scrollSegmentDurationMin'),
        this.config.get('scrollSegmentDurationMax')
      );
      const steps = Math.max(20, Math.round(totalDuration / 50));
      const stepDuration = totalDuration / steps;

      // éšæœºè´å¡å°”æ§åˆ¶ç‚¹
      const p0 = 0, p3 = 1;
      const p1 = Utils.getRandomFloat(this.config.get('bezierP1Min'), this.config.get('bezierP1Max'));
      const p2 = Utils.getRandomFloat(this.config.get('bezierP2Min'), this.config.get('bezierP2Max'));

      this.logger.log(`å‘ä¸Šæ»šåŠ¨: ${Math.round(startY)} â†’ ${Math.round(targetY)} (${Math.round(startY - targetY)}px, ${totalDuration}ms)`, 'action');

      let currentStep = 0;

      return new Promise((resolve) => {
        this.scrollInterval = setInterval(async () => {
          if (currentStep >= steps) {
            clearInterval(this.scrollInterval);
            this.scrollInterval = null;
            this.isScrolling = false;

            window.scrollTo(0, targetY);
            this.statusIndicator.updateStatus('idle');
            this.logger.log("å‘ä¸Šæ»šåŠ¨å®Œæˆ", 'success');

            // éšæœºè§¦å‘è¡Œä¸ºæ¨¡æ‹Ÿ
            if (Math.random() < 0.3) {
              await this.behaviorSimulator.simulatePageInteraction();
            }

            resolve(true);
            return;
          }

          const t = currentStep / steps;
          const progress = Utils.cubicBezier(t, p0, p1, p2, p3);
          const scrollPosition = startY - (startY - targetY) * progress;

          window.scrollTo(0, scrollPosition);

          // æ›´æ–°è¿›åº¦
          const scrollProgress = (currentStep / steps) * 100;
          this.statusIndicator.updateStatus('scrolling', scrollProgress);

          currentStep++;

          // éšæœºæš‚åœ
          if (Math.random() < this.config.get('randomPauseProbability')) {
            const pauseDuration = Utils.getRandomInt(
              this.config.get('randomPauseDurationMin'),
              this.config.get('randomPauseDurationMax')
            );
            await Utils.sleep(pauseDuration);
          }
        }, stepDuration);
      });
    }

    // æ™ºèƒ½æ»šåŠ¨å†³ç­–
    async performIntelligentScroll() {
      if (this.isScrolling) return false;

      const documentHeight = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
      const windowHeight = window.innerHeight;
      const currentY = window.scrollY;
      const isAtBottom = currentY + windowHeight >= documentHeight - 10;
      const isAtTop = currentY <= 10;

      let scrollSuccess = false;

      if (this.scrollDirection === 'down') {
        if (isAtBottom) {
          this.logger.log("åˆ°è¾¾åº•éƒ¨ï¼Œåˆ‡æ¢ä¸ºå‘ä¸Šæ»šåŠ¨", 'info');
          this.scrollDirection = 'up';
          scrollSuccess = await this.scrollUpWithBezier();
        } else {
          scrollSuccess = await this.scrollWithBezier();
        }
      } else { // scrollDirection === 'up'
        if (isAtTop) {
          this.logger.log("åˆ°è¾¾é¡¶éƒ¨ï¼Œåˆ‡æ¢ä¸ºå‘ä¸‹æ»šåŠ¨", 'info');
          this.scrollDirection = 'down';
          scrollSuccess = await this.scrollWithBezier();
        } else {
          scrollSuccess = await this.scrollUpWithBezier();
        }
      }

      return scrollSuccess;
    }

    // åœæ­¢æ‰€æœ‰æ»šåŠ¨
    stopScrolling() {
      if (this.scrollInterval) {
        clearInterval(this.scrollInterval);
        this.scrollInterval = null;
      }
      if (this.checkScrollTimeout) {
        clearTimeout(this.checkScrollTimeout);
        this.checkScrollTimeout = null;
      }
      this.isScrolling = false;
      this.statusIndicator.updateStatus('idle');
    }

    // æ£€æŸ¥æ˜¯å¦å¡ä½
    isStuck() {
      const currentScrollY = window.scrollY;
      const scrollDelta = Math.abs(currentScrollY - this.lastScrollY);
      const timeSinceLastScroll = Date.now() - this.scrollStartTime;

      const isStuck = !this.isScrolling &&
                     scrollDelta < this.config.get('minScrollDelta') &&
                     timeSinceLastScroll > this.config.get('stuckTimeout');

      if (!this.isScrolling) {
        this.lastScrollY = currentScrollY;
      }

      return isStuck;
    }
  }

  // ===== æ•°æ®åˆ†æç±» =====
  class DataAnalyzer {
    constructor(config, logger) {
      this.config = config;
      this.logger = logger;
      this.sessionData = {
        startTime: Date.now(),
        topicsVisited: [],
        scrollEvents: [],
        likeEvents: [],
        errorEvents: [],
        behaviorEvents: []
      };
      this.historicalData = this.loadHistoricalData();
    }

    // åŠ è½½å†å²æ•°æ®
    loadHistoricalData() {
      try {
        const data = GM_getValue('analyticsData', null);
        const parsedData = data ? JSON.parse(data) : {};
        const defaults = {
          totalSessions: 0,
          totalTopicsRead: 0,
          totalLikesGiven: 0,
          totalReadingTime: 0,
          dailyStats: {},
          weeklyStats: {},
          monthlyStats: {},
          topicCategories: {},
          readingPatterns: [],
          efficiencyMetrics: []
        };
        return { ...defaults, ...parsedData };
      } catch (e) {
        return {
          totalSessions: 0,
          totalTopicsRead: 0,
          totalLikesGiven: 0,
          totalReadingTime: 0,
          dailyStats: {},
          weeklyStats: {},
          monthlyStats: {},
          topicCategories: {},
          readingPatterns: [],
          efficiencyMetrics: []
        };
      }
    }

    // ä¿å­˜å†å²æ•°æ®
    saveHistoricalData() {
      try {
        GM_setValue('analyticsData', JSON.stringify(this.historicalData));
      } catch (e) {
        this.logger.log('ä¿å­˜åˆ†ææ•°æ®å¤±è´¥', 'error');
      }
    }

    // è®°å½•è¯é¢˜è®¿é—®
    recordTopicVisit(topicId, topicTitle, category, readTime) {
      const visitData = {
        topicId,
        topicTitle,
        category: category || 'unknown',
        readTime,
        timestamp: Date.now(),
        scrollCount: this.sessionData.scrollEvents.length,
        likeGiven: this.sessionData.likeEvents.some(e => e.topicId === topicId)
      };

      this.sessionData.topicsVisited.push(visitData);
      this.updateHistoricalStats(visitData);
      this.logger.log(`è®°å½•è¯é¢˜è®¿é—®: ${topicTitle} (${Utils.formatTime(readTime)})`, 'action');
    }

    // è®°å½•æ»šåŠ¨äº‹ä»¶
    recordScrollEvent(direction, distance, duration) {
      const scrollData = {
        direction,
        distance,
        duration,
        timestamp: Date.now(),
        scrollSpeed: distance / duration
      };

      this.sessionData.scrollEvents.push(scrollData);
    }

    // è®°å½•ç‚¹èµäº‹ä»¶
    recordLikeEvent(topicId, postId) {
      const likeData = {
        topicId,
        postId,
        timestamp: Date.now()
      };

      this.sessionData.likeEvents.push(likeData);
      this.historicalData.totalLikesGiven++;
    }

    // è®°å½•é”™è¯¯äº‹ä»¶
    recordErrorEvent(errorType, errorMessage, context) {
      const errorData = {
        type: errorType,
        message: errorMessage,
        context,
        timestamp: Date.now()
      };

      this.sessionData.errorEvents.push(errorData);
    }

    // è®°å½•è¡Œä¸ºäº‹ä»¶
    recordBehaviorEvent(behaviorType, details) {
      const behaviorData = {
        type: behaviorType,
        details,
        timestamp: Date.now()
      };

      this.sessionData.behaviorEvents.push(behaviorData);
    }

    // æ›´æ–°å†å²ç»Ÿè®¡
    updateHistoricalStats(visitData) {
      const today = new Date().toISOString().split('T')[0];
      const thisWeek = this.getWeekKey(new Date());
      const thisMonth = new Date().toISOString().substring(0, 7);

      // æ›´æ–°æ€»è®¡
      this.historicalData.totalTopicsRead++;
      this.historicalData.totalReadingTime += visitData.readTime;

      // æ›´æ–°æ—¥ç»Ÿè®¡
      if (!this.historicalData.dailyStats[today]) {
        this.historicalData.dailyStats[today] = {
          topicsRead: 0,
          readingTime: 0,
          likesGiven: 0,
          categories: {}
        };
      }
      this.historicalData.dailyStats[today].topicsRead++;
      this.historicalData.dailyStats[today].readingTime += visitData.readTime;

      // æ›´æ–°å‘¨ç»Ÿè®¡
      if (!this.historicalData.weeklyStats[thisWeek]) {
        this.historicalData.weeklyStats[thisWeek] = {
          topicsRead: 0,
          readingTime: 0,
          likesGiven: 0
        };
      }
      this.historicalData.weeklyStats[thisWeek].topicsRead++;
      this.historicalData.weeklyStats[thisWeek].readingTime += visitData.readTime;

      // æ›´æ–°æœˆç»Ÿè®¡
      if (!this.historicalData.monthlyStats[thisMonth]) {
        this.historicalData.monthlyStats[thisMonth] = {
          topicsRead: 0,
          readingTime: 0,
          likesGiven: 0
        };
      }
      this.historicalData.monthlyStats[thisMonth].topicsRead++;
      this.historicalData.monthlyStats[thisMonth].readingTime += visitData.readTime;

      // æ›´æ–°åˆ†ç±»ç»Ÿè®¡
      if (!this.historicalData.topicCategories[visitData.category]) {
        this.historicalData.topicCategories[visitData.category] = {
          count: 0,
          totalTime: 0,
          avgTime: 0
        };
      }
      const categoryStats = this.historicalData.topicCategories[visitData.category];
      if (!categoryStats) {
        this.historicalData.topicCategories[visitData.category] = {
          count: 0,
          totalTime: 0,
          avgTime: 0
        };
      }
      categoryStats.count++;
      categoryStats.totalTime += visitData.readTime;
      categoryStats.avgTime = categoryStats.totalTime / categoryStats.count;
    }

    // ç”Ÿæˆæ•ˆç‡æŠ¥å‘Š
    generateEfficiencyReport() {
      const sessionDuration = Date.now() - this.sessionData.startTime;
      const topicsPerHour = (this.sessionData.topicsVisited.length / (sessionDuration / 3600000)).toFixed(2);
      const avgReadTime = this.sessionData.topicsVisited.length > 0
        ? this.sessionData.topicsVisited.reduce((sum, t) => sum + t.readTime, 0) / this.sessionData.topicsVisited.length
        : 0;

      const report = {
        session: {
          duration: sessionDuration,
          topicsRead: this.sessionData.topicsVisited.length,
          topicsPerHour: parseFloat(topicsPerHour),
          avgReadTime,
          scrollEvents: this.sessionData.scrollEvents.length,
          likeEvents: this.sessionData.likeEvents.length,
          errorEvents: this.sessionData.errorEvents.length
        },
        historical: {
          totalSessions: this.historicalData.totalSessions,
          totalTopicsRead: this.historicalData.totalTopicsRead,
          totalReadingTime: this.historicalData.totalReadingTime,
          avgTopicsPerSession: this.historicalData.totalSessions > 0
            ? (this.historicalData.totalTopicsRead / this.historicalData.totalSessions).toFixed(2)
            : 0
        },
        trends: this.analyzeTrends(),
        recommendations: this.generateRecommendations()
      };

      return report;
    }

    // åˆ†æè¶‹åŠ¿
    analyzeTrends() {
      const recentDays = Object.keys(this.historicalData.dailyStats)
        .sort()
        .slice(-7);

      if (recentDays.length < 2) return null;

      const firstDay = this.historicalData.dailyStats[recentDays[0]];
      const lastDay = this.historicalData.dailyStats[recentDays[recentDays.length - 1]];

      return {
        topicsReadTrend: lastDay.topicsRead - firstDay.topicsRead,
        readingTimeTrend: lastDay.readingTime - firstDay.readingTime,
        period: `${recentDays[0]} åˆ° ${recentDays[recentDays.length - 1]}`
      };
    }

    // ç”Ÿæˆå»ºè®®
    generateRecommendations() {
      const recommendations = [];
      const avgReadTime = this.sessionData.topicsVisited.length > 0
        ? this.sessionData.topicsVisited.reduce((sum, t) => sum + t.readTime, 0) / this.sessionData.topicsVisited.length
        : 0;

      if (avgReadTime < 30000) {
        recommendations.push('å»ºè®®å¢åŠ æ¯ä¸ªè¯é¢˜çš„é˜…è¯»æ—¶é—´ï¼Œæé«˜å†…å®¹ç†è§£åº¦');
      }

      if (this.sessionData.errorEvents.length > 5) {
        recommendations.push('æ£€æµ‹åˆ°è¾ƒå¤šé”™è¯¯ï¼Œå»ºè®®æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–è°ƒæ•´é…ç½®');
      }

      const scrollToReadRatio = this.sessionData.scrollEvents.length / Math.max(this.sessionData.topicsVisited.length, 1);
      if (scrollToReadRatio > 20) {
        recommendations.push('æ»šåŠ¨é¢‘ç‡è¾ƒé«˜ï¼Œå»ºè®®è°ƒæ•´æ»šåŠ¨å‚æ•°ä»¥æé«˜æ•ˆç‡');
      }

      return recommendations;
    }

    // è·å–å‘¨é”®
    getWeekKey(date) {
      const year = date.getFullYear();
      const week = this.getWeekNumber(date);
      return `${year}-W${week.toString().padStart(2, '0')}`;
    }

    // è·å–å‘¨æ•°
    getWeekNumber(date) {
      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const dayNum = d.getUTCDay() || 7;
      d.setUTCDate(d.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
      return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    }

    // ç»“æŸä¼šè¯
    endSession() {
      this.historicalData.totalSessions++;
      this.saveHistoricalData();

      const report = this.generateEfficiencyReport();
      this.logger.log(`ä¼šè¯ç»“æŸ - é˜…è¯» ${report.session.topicsRead} ä¸ªè¯é¢˜ï¼Œç”¨æ—¶ ${Utils.formatTime(report.session.duration)}`, 'success');

      return report;
    }

    // å¯¼å‡ºåˆ†ææ•°æ®
    exportAnalyticsData() {
      const exportData = {
        sessionData: this.sessionData,
        historicalData: this.historicalData,
        report: this.generateEfficiencyReport(),
        exportTime: new Date().toISOString()
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], {
        type: 'application/json'
      });

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `forum-assistant-analytics-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      this.logger.log('åˆ†ææ•°æ®å·²å¯¼å‡º', 'success');
    }
  }

  // ===== å®‰å…¨å’Œéšç§å¢å¼ºç±» =====
  class SecurityManager {
    constructor(config, logger) {
      this.config = config;
      this.logger = logger;
      this.userAgents = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15'
      ];
      this.proxyList = [];
      this.currentFingerprint = this.generateFingerprint();
    }

    // ç”ŸæˆéšæœºæŒ‡çº¹
    generateFingerprint() {
      return {
        userAgent: this.getRandomUserAgent(),
        language: this.getRandomLanguage(),
        timezone: this.getRandomTimezone(),
        screen: this.getRandomScreen(),
        colorDepth: this.getRandomColorDepth(),
        platform: this.getRandomPlatform()
      };
    }

    // è·å–éšæœºUser-Agent
    getRandomUserAgent() {
      return this.userAgents[Math.floor(Math.random() * this.userAgents.length)];
    }

    // è·å–éšæœºè¯­è¨€
    getRandomLanguage() {
      const languages = ['zh-CN', 'zh-TW', 'en-US', 'en-GB', 'ja-JP', 'ko-KR'];
      return languages[Math.floor(Math.random() * languages.length)];
    }

    // è·å–éšæœºæ—¶åŒº
    getRandomTimezone() {
      const timezones = [
        'Asia/Shanghai', 'Asia/Hong_Kong', 'Asia/Taipei',
        'Asia/Tokyo', 'Asia/Seoul', 'America/New_York',
        'Europe/London', 'Australia/Sydney'
      ];
      return timezones[Math.floor(Math.random() * timezones.length)];
    }

    // è·å–éšæœºå±å¹•åˆ†è¾¨ç‡
    getRandomScreen() {
      const screens = [
        { width: 1920, height: 1080 },
        { width: 1366, height: 768 },
        { width: 1440, height: 900 },
        { width: 1536, height: 864 },
        { width: 2560, height: 1440 }
      ];
      return screens[Math.floor(Math.random() * screens.length)];
    }

    // è·å–éšæœºé¢œè‰²æ·±åº¦
    getRandomColorDepth() {
      const depths = [24, 32];
      return depths[Math.floor(Math.random() * depths.length)];
    }

    // è·å–éšæœºå¹³å°
    getRandomPlatform() {
      const platforms = ['Win32', 'MacIntel', 'Linux x86_64'];
      return platforms[Math.floor(Math.random() * platforms.length)];
    }

    // éšæœºåŒ–è¯·æ±‚å¤´
    randomizeHeaders(baseHeaders = {}) {
      const randomHeaders = {
        'User-Agent': this.currentFingerprint.userAgent,
        'Accept-Language': `${this.currentFingerprint.language},en;q=0.9`,
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Encoding': 'gzip, deflate, br',
        'DNT': Math.random() > 0.5 ? '1' : '0',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Cache-Control': Math.random() > 0.5 ? 'no-cache' : 'max-age=0'
      };

      // éšæœºæ·»åŠ ä¸€äº›å¯é€‰å¤´
      if (Math.random() > 0.7) {
        randomHeaders['Sec-CH-UA'] = this.generateSecChUa();
      }

      if (Math.random() > 0.8) {
        randomHeaders['Sec-CH-UA-Mobile'] = '?0';
        randomHeaders['Sec-CH-UA-Platform'] = `"${this.currentFingerprint.platform}"`;
      }

      return { ...randomHeaders, ...baseHeaders };
    }

    // ç”ŸæˆSec-CH-UAå¤´
    generateSecChUa() {
      const brands = [
        '"Google Chrome";v="120", "Chromium";v="120", "Not_A Brand";v="99"',
        '"Google Chrome";v="119", "Chromium";v="119", "Not_A Brand";v="99"',
        '"Microsoft Edge";v="120", "Chromium";v="120", "Not_A Brand";v="99"'
      ];
      return brands[Math.floor(Math.random() * brands.length)];
    }

    // å¢å¼ºçš„fetchè¯·æ±‚
    async secureRequest(url, options = {}) {
      if (!this.config.get('enableSafetyFeatures')) {
        return fetch(url, options);
      }

      // éšæœºå»¶è¿Ÿ
      const delay = Utils.getRandomInt(100, 500);
      await Utils.sleep(delay);

      // éšæœºåŒ–è¯·æ±‚å¤´
      const secureHeaders = this.randomizeHeaders(options.headers || {});

      const secureOptions = {
        ...options,
        headers: secureHeaders
      };

      // å¦‚æœå¯ç”¨ä»£ç†
      if (this.config.get('proxyEnabled') && this.proxyList.length > 0) {
        // è¿™é‡Œå¯ä»¥æ·»åŠ ä»£ç†é€»è¾‘
        this.logger.log('ä½¿ç”¨ä»£ç†å‘é€è¯·æ±‚', 'action');
      }

      try {
        const response = await fetch(url, secureOptions);

        // è®°å½•è¯·æ±‚
        this.logger.log(`å®‰å…¨è¯·æ±‚: ${url.substring(0, 50)}...`, 'action');

        return response;
      } catch (error) {
        this.logger.log(`å®‰å…¨è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
        throw error;
      }
    }

    // è¡Œä¸ºæŒ‡çº¹æ··æ·†
    obfuscateBehavior() {
      if (!this.config.get('enableSafetyFeatures')) return;

      // éšæœºæ”¹å˜æŒ‡çº¹
      if (Math.random() < 0.1) {
        this.currentFingerprint = this.generateFingerprint();
        this.logger.log('æ›´æ–°è¡Œä¸ºæŒ‡çº¹', 'action');
      }

      // éšæœºæ·»åŠ å™ªå£°äº‹ä»¶
      this.addNoiseEvents();
    }

    // æ·»åŠ å™ªå£°äº‹ä»¶
    addNoiseEvents() {
      const noiseEvents = [
        () => this.simulateRandomClick(),
        () => this.simulateRandomKeyPress(),
        () => this.simulateRandomMouseMove(),
        () => this.simulateRandomScroll()
      ];

      // éšæœºæ‰§è¡Œ1-2ä¸ªå™ªå£°äº‹ä»¶
      const eventCount = Utils.getRandomInt(1, 2);
      for (let i = 0; i < eventCount; i++) {
        const randomEvent = noiseEvents[Math.floor(Math.random() * noiseEvents.length)];
        setTimeout(randomEvent, Utils.getRandomInt(100, 1000));
      }
    }

    // æ¨¡æ‹Ÿéšæœºç‚¹å‡»
    simulateRandomClick() {
      const x = Math.random() * window.innerWidth;
      const y = Math.random() * window.innerHeight;

      const clickEvent = new MouseEvent('click', {
        clientX: x,
        clientY: y,
        bubbles: false // ä¸å†’æ³¡ï¼Œé¿å…è§¦å‘å®é™…åŠŸèƒ½
      });

      // åˆ›å»ºä¸€ä¸ªä¸å¯è§çš„å…ƒç´ æ¥æ¥æ”¶ç‚¹å‡»
      const dummyElement = document.createElement('div');
      dummyElement.style.position = 'absolute';
      dummyElement.style.left = x + 'px';
      dummyElement.style.top = y + 'px';
      dummyElement.style.width = '1px';
      dummyElement.style.height = '1px';
      dummyElement.style.opacity = '0';
      dummyElement.style.pointerEvents = 'none';

      document.body.appendChild(dummyElement);
      dummyElement.dispatchEvent(clickEvent);

      setTimeout(() => {
        document.body.removeChild(dummyElement);
      }, 100);
    }

    // æ¨¡æ‹ŸéšæœºæŒ‰é”®
    simulateRandomKeyPress() {
      const keys = ['Tab', 'Shift', 'Control', 'Alt'];
      const randomKey = keys[Math.floor(Math.random() * keys.length)];

      const keyEvent = new KeyboardEvent('keydown', {
        key: randomKey,
        bubbles: false
      });

      document.dispatchEvent(keyEvent);
    }

    // æ¨¡æ‹Ÿéšæœºé¼ æ ‡ç§»åŠ¨
    simulateRandomMouseMove() {
      const x = Math.random() * window.innerWidth;
      const y = Math.random() * window.innerHeight;

      const moveEvent = new MouseEvent('mousemove', {
        clientX: x,
        clientY: y,
        bubbles: false
      });

      document.dispatchEvent(moveEvent);
    }

    // æ¨¡æ‹Ÿéšæœºæ»šåŠ¨
    simulateRandomScroll() {
      const scrollEvent = new WheelEvent('wheel', {
        deltaY: Utils.getRandomInt(-100, 100),
        bubbles: false
      });

      document.dispatchEvent(scrollEvent);
    }

    // æ£€æµ‹åçˆ¬è™«æœºåˆ¶
    detectAntiBot() {
      const indicators = [];

      // æ£€æµ‹å¸¸è§çš„åçˆ¬è™«è„šæœ¬
      if (window.navigator.webdriver) {
        indicators.push('webdriver detected');
      }

      if (window.chrome && window.chrome.runtime && window.chrome.runtime.onConnect) {
        // å¯èƒ½æ˜¯è‡ªåŠ¨åŒ–æµè§ˆå™¨
        indicators.push('automation detected');
      }

      // æ£€æµ‹å¼‚å¸¸çš„æ€§èƒ½æŒ‡æ ‡
      if (performance.timing) {
        const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
        if (loadTime < 100) {
          indicators.push('suspicious load time');
        }
      }

      if (indicators.length > 0) {
        this.logger.log(`æ£€æµ‹åˆ°åçˆ¬è™«æŒ‡æ ‡: ${indicators.join(', ')}`, 'warn');
        return true;
      }

      return false;
    }

    // å¯åŠ¨å®‰å…¨ç›‘æ§
    startSecurityMonitoring() {
      if (!this.config.get('enableSafetyFeatures')) return;

      // å®šæœŸæ£€æµ‹åçˆ¬è™«
      setInterval(() => {
        if (this.detectAntiBot()) {
          this.obfuscateBehavior();
        }
      }, 30000);

      // å®šæœŸæ··æ·†è¡Œä¸º
      setInterval(() => {
        this.obfuscateBehavior();
      }, Utils.getRandomInt(60000, 120000));

      this.logger.log('å®‰å…¨ç›‘æ§å·²å¯åŠ¨', 'success');
    }

    // æ¸…ç†ç—•è¿¹
    cleanupTraces() {
      try {
        // æ¸…ç†localStorageä¸­çš„æ•æ„Ÿæ•°æ®
        const sensitiveKeys = ['topicList', 'latestPage', 'clickCounter'];
        sensitiveKeys.forEach(key => {
          if (Math.random() < 0.1) { // 10%æ¦‚ç‡æ¸…ç†
            localStorage.removeItem(key);
          }
        });

        // æ¸…ç†sessionStorage
        if (Math.random() < 0.05) { // 5%æ¦‚ç‡æ¸…ç†
          sessionStorage.clear();
        }

        this.logger.log('æ‰§è¡Œç—•è¿¹æ¸…ç†', 'action');
      } catch (e) {
        // å¿½ç•¥æ¸…ç†é”™è¯¯
      }
    }
  }

  // ===== å¤šç«™ç‚¹é€‚é…å™¨ç±» =====
  class SiteAdapter {
    constructor(config, logger) {
      this.config = config;
      this.logger = logger;
      this.currentSite = this.detectSite();
      this.siteConfigs = this.initializeSiteConfigs();
    }

    // æ£€æµ‹å½“å‰ç«™ç‚¹
    detectSite() {
      const url = window.location.href;
      const hostname = window.location.hostname;

      const siteMap = {
        'linux.do': 'linuxdo',
        'meta.discourse.org': 'discourse-meta',
        'meta.appinn.net': 'appinn',
        'community.openai.com': 'openai',
        'www.nodeloc.com': 'nodeloc',
        'bbs.tampermonkey.net.cn': 'tampermonkey',
        'greasyfork.org': 'greasyfork'
      };

      for (const [domain, siteId] of Object.entries(siteMap)) {
        if (hostname.includes(domain)) {
          this.logger.log(`æ£€æµ‹åˆ°ç«™ç‚¹: ${siteId}`, 'info');
          return siteId;
        }
      }

      // å°è¯•æ£€æµ‹Discourseè®ºå›
      if (this.isDiscourse()) {
        this.logger.log('æ£€æµ‹åˆ°Discourseè®ºå›', 'info');
        return 'discourse-generic';
      }

      this.logger.log('æœªçŸ¥ç«™ç‚¹ç±»å‹', 'warn');
      return 'unknown';
    }

    // æ£€æµ‹æ˜¯å¦ä¸ºDiscourseè®ºå›
    isDiscourse() {
      return !!(
        document.querySelector('meta[name="discourse_theme_ids"]') ||
        document.querySelector('meta[name="discourse_current_homepage"]') ||
        document.querySelector('#discourse-modal') ||
        window.Discourse ||
        document.body.classList.contains('discourse')
      );
    }

    // åˆå§‹åŒ–ç«™ç‚¹é…ç½®
    initializeSiteConfigs() {
      return {
        'linuxdo': {
          name: 'Linux.do',
          type: 'discourse',
          apiEndpoint: '/latest.json',
          topicUrlPattern: '/t/topic/{id}/{post}',
          selectors: {
            likeButton: '.discourse-reactions-reaction-button:not(.my-reaction)',
            topicTitle: '.fancy-title',
            postContent: '.cooked',
            userAvatar: '.avatar',
            replyButton: '.reply'
          },
          features: {
            reactions: true,
            categories: true,
            tags: true,
            privateMessages: true
          },
          limits: {
            maxComments: 1000,
            maxLikes: 50,
            readTimeMin: 45000,
            readTimeMax: 120000
          }
        },

        'nodeloc': {
          name: 'NodeLoc',
          type: 'discourse',
          apiEndpoint: '/latest.json',
          topicUrlPattern: '/t/topic/{id}/{post}',
          selectors: {
            likeButton: '.discourse-reactions-reaction-button:not(.my-reaction)',
            topicTitle: '.fancy-title',
            postContent: '.cooked'
          },
          features: {
            reactions: true,
            categories: true
          },
          limits: {
            maxComments: 800,
            maxLikes: 40,
            readTimeMin: 30000,
            readTimeMax: 90000
          }
        },

        'discourse-meta': {
          name: 'Discourse Meta',
          type: 'discourse',
          apiEndpoint: '/latest.json',
          topicUrlPattern: '/t/{slug}/{id}/{post}',
          selectors: {
            likeButton: '.like-button:not(.has-like)',
            topicTitle: '.fancy-title',
            postContent: '.cooked'
          },
          features: {
            likes: true,
            categories: true,
            tags: true
          },
          limits: {
            maxComments: 1500,
            maxLikes: 60,
            readTimeMin: 60000,
            readTimeMax: 150000
          }
        },

        'greasyfork': {
          name: 'Greasy Fork',
          type: 'custom',
          apiEndpoint: null,
          selectors: {
            scriptLink: 'a[href*="/scripts/"]',
            scriptTitle: '.script-name',
            scriptDescription: '.script-description'
          },
          features: {
            scripts: true,
            reviews: true
          },
          limits: {
            maxScripts: 100,
            readTimeMin: 20000,
            readTimeMax: 60000
          }
        },

        'unknown': {
          name: 'Unknown Site',
          type: 'generic',
          apiEndpoint: null,
          selectors: {
            likeButton: '.like, .upvote, [data-action="like"]',
            content: 'article, .post, .content'
          },
          features: {},
          limits: {
            maxComments: 500,
            maxLikes: 20,
            readTimeMin: 30000,
            readTimeMax: 90000
          }
        }
      };
    }

    // è·å–å½“å‰ç«™ç‚¹é…ç½®
    getSiteConfig() {
      return this.siteConfigs[this.currentSite] || this.siteConfigs['unknown'];
    }

    // è·å–APIç«¯ç‚¹
    getApiEndpoint(endpoint) {
      const siteConfig = this.getSiteConfig();
      const baseUrl = `${window.location.protocol}//${window.location.hostname}`;

      switch (endpoint) {
        case 'latest':
          return siteConfig.apiEndpoint ? `${baseUrl}${siteConfig.apiEndpoint}` : null;
        case 'topics':
          return `${baseUrl}/topics.json`;
        case 'categories':
          return `${baseUrl}/categories.json`;
        default:
          return null;
      }
    }

    // æ„å»ºè¯é¢˜URL
    buildTopicUrl(topicId, postNumber = 1) {
      const siteConfig = this.getSiteConfig();
      const baseUrl = `${window.location.protocol}//${window.location.hostname}`;

      if (siteConfig.topicUrlPattern) {
        return `${baseUrl}${siteConfig.topicUrlPattern
          .replace('{id}', topicId)
          .replace('{post}', postNumber)
          .replace('{slug}', 'topic')}`;
      }

      return `${baseUrl}/t/${topicId}`;
    }

    // è·å–é€‰æ‹©å™¨
    getSelector(type) {
      const siteConfig = this.getSiteConfig();
      return siteConfig.selectors[type] || null;
    }

    // æ£€æŸ¥åŠŸèƒ½æ”¯æŒ
    hasFeature(feature) {
      const siteConfig = this.getSiteConfig();
      return siteConfig.features[feature] || false;
    }

    // è·å–é™åˆ¶é…ç½®
    getLimit(type) {
      const siteConfig = this.getSiteConfig();
      return siteConfig.limits[type] || 0;
    }

    // ç«™ç‚¹ç‰¹å®šçš„è¯é¢˜è·å–
    async fetchTopics(page = 0) {
      const apiUrl = this.getApiEndpoint('latest');
      if (!apiUrl) {
        this.logger.log('å½“å‰ç«™ç‚¹ä¸æ”¯æŒAPIè·å–è¯é¢˜', 'warn');
        return [];
      }

      try {
        const url = `${apiUrl}?no_definitions=true&page=${page}`;
        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        const topics = data?.topic_list?.topics || [];

        // ç«™ç‚¹ç‰¹å®šçš„è¿‡æ»¤é€»è¾‘
        return this.filterTopics(topics);

      } catch (error) {
        this.logger.log(`è·å–è¯é¢˜å¤±è´¥: ${error.message}`, 'error');
        return [];
      }
    }

    // è¿‡æ»¤è¯é¢˜
    filterTopics(topics) {
      const maxComments = this.getLimit('maxComments');

      return topics.filter(topic => {
        if (!topic || !topic.id) return false;
        if (topic.posts_count > maxComments) return false;
        if (topic.closed || topic.archived) return false;

        // ç«™ç‚¹ç‰¹å®šè¿‡æ»¤
        switch (this.currentSite) {
          case 'linuxdo':
            // è¿‡æ»¤æ‰æŸäº›åˆ†ç±»
            if (topic.category_id && [1, 2].includes(topic.category_id)) return false;
            break;
          case 'nodeloc':
            // åªä¿ç•™ç‰¹å®šåˆ†ç±»
            if (topic.category_id && ![5, 6, 7].includes(topic.category_id)) return false;
            break;
        }

        return true;
      });
    }

    // ç«™ç‚¹ç‰¹å®šçš„ç‚¹èµé€»è¾‘
    async performLike(element) {
      const siteConfig = this.getSiteConfig();

      if (!this.hasFeature('reactions') && !this.hasFeature('likes')) {
        return false;
      }

      try {
        // æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯ç‚¹å‡»
        if (element.classList.contains('my-reaction') ||
            element.classList.contains('has-like') ||
            element.disabled) {
          return false;
        }

        // æ¨¡æ‹Ÿç‚¹å‡»
        const event = new MouseEvent('click', {
          bubbles: true,
          cancelable: true
        });

        element.dispatchEvent(event);

        // ç­‰å¾…å“åº”
        await Utils.sleep(Utils.getRandomInt(500, 1500));

        return true;

      } catch (error) {
        this.logger.log(`ç‚¹èµå¤±è´¥: ${error.message}`, 'error');
        return false;
      }
    }

    // è·å–é¡µé¢ä¿¡æ¯
    getPageInfo() {
      const siteConfig = this.getSiteConfig();

      return {
        site: this.currentSite,
        siteName: siteConfig.name,
        type: siteConfig.type,
        url: window.location.href,
        title: document.title,
        isTopicPage: this.isTopicPage(),
        topicId: this.extractTopicId(),
        hasLikeButtons: this.hasLikeButtons()
      };
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºè¯é¢˜é¡µé¢
    isTopicPage() {
      const patterns = [
        /\/t\/[^/]+\/\d+/,  // Discourse pattern
        /\/topic\/\d+/,     // Generic topic pattern
        /\/thread\/\d+/,    // Forum thread pattern
        /\/scripts\/\d+/    // Greasyfork script pattern
      ];

      return patterns.some(pattern => pattern.test(window.location.pathname));
    }

    // æå–è¯é¢˜ID
    extractTopicId() {
      const path = window.location.pathname;
      const matches = path.match(/\/(?:t|topic|thread|scripts)\/(?:[^/]+\/)?(\d+)/);
      return matches ? parseInt(matches[1]) : null;
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰ç‚¹èµæŒ‰é’®
    hasLikeButtons() {
      const selector = this.getSelector('likeButton');
      return selector ? document.querySelectorAll(selector).length > 0 : false;
    }
  }

  // ===== ä¸»ç¨‹åºç±» =====
  class ForumAssistant {
    constructor() {
      this.config = new ConfigManager();
      this.logger = new LogManager(this.config);
      this.statusIndicator = new StatusIndicator(this.config, this.logger);
      this.behaviorSimulator = new BehaviorSimulator(this.config, this.logger, this.statusIndicator);
      this.scrollSystem = new EnhancedScrollSystem(this.config, this.logger, this.statusIndicator, this.behaviorSimulator);
      this.dataAnalyzer = new DataAnalyzer(this.config, this.logger);
      this.securityManager = new SecurityManager(this.config, this.logger);
      this.siteAdapter = new SiteAdapter(this.config, this.logger);
      this.automationEngine = new AutomationEngine(this.config, this.logger, this.siteAdapter);

      // UIç»„ä»¶
      this.statsPanel = new StatisticsPanel(this.config, this.logger);
      this.configPanel = new ConfigPanel(this.config, this.logger);
      this.upgradePanel = new UpgradeProgressPanel(this.config, this.logger);
      this.controlPanel = new ControlPanel(this.config, this.logger, this.statsPanel, this.configPanel, this.upgradePanel);

      // çŠ¶æ€å˜é‡
      this.isRunning = false;
      this.currentTopic = null;
      this.topicStartTime = Date.now();
      this.requiredReadTime = 0;
      this.mainLoop = null;
      this.stuckCheckInterval = null;

      this.initialize();
    }

    // åˆå§‹åŒ–
    async initialize() {
      try {
        this.logger.log('æ™ºèƒ½è®ºå›åŠ©æ‰‹ Pro åˆå§‹åŒ–ä¸­...', 'info');

        // ç­‰å¾…DOMå®Œå…¨å‡†å¤‡å¥½
        await this.waitForDOM();

        // åˆ›å»ºUI (ä½¿ç”¨å»¶è¿Ÿç¡®ä¿DOMç¨³å®š)
        setTimeout(() => {
          try {
            this.logger.createLogWindow();
            this.statusIndicator.create();
            this.controlPanel.create();

            if (this.config.get('showStatistics')) {
              this.statsPanel.show();
            }

            // æ¢å¤å‡çº§è¿›åº¦çª—å£çŠ¶æ€
            const upgradeProgressVisible = GM_getValue('upgradeProgressVisible', false);
            if (upgradeProgressVisible) {
              this.upgradePanel.show();
            }
          } catch (uiError) {
            console.error('UIåˆ›å»ºå¤±è´¥:', uiError);
            this.logger.log(`UIåˆ›å»ºå¤±è´¥: ${uiError.message}`, 'error');
          }
        }, 500);

        // å¯åŠ¨å®‰å…¨ç›‘æ§
        this.securityManager.startSecurityMonitoring();

      // å¯åŠ¨å¼¹çª—ç›‘æ§
      this.startPopupMonitoring();

      // å¯åŠ¨ç½‘ç»œè¯·æ±‚ç›‘æ§
      this.startNetworkMonitoring();

        // æ£€æŸ¥ç«™ç‚¹å…¼å®¹æ€§
        const pageInfo = this.siteAdapter.getPageInfo();
        this.logger.log(`å½“å‰ç«™ç‚¹: ${pageInfo.siteName} (${pageInfo.type})`, 'info');

        // æ¢å¤è¿è¡ŒçŠ¶æ€
        const wasRunning = GM_getValue('isReading', false);
        if (wasRunning) {
          await Utils.sleep(2000); // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½
          this.start();
        }

        this.logger.log('åˆå§‹åŒ–å®Œæˆ', 'success');

        this.setupNavigationListener();

      } catch (error) {
        console.error('åˆå§‹åŒ–é”™è¯¯:', error);
        this.logger.log(`åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // è®¾ç½®å¯¼èˆªç›‘å¬å™¨
    setupNavigationListener() {
        this.lastUrl = window.location.href;

        const observer = new MutationObserver(() => {
            const currentUrl = window.location.href;
            if (currentUrl !== this.lastUrl) {
                this.handleUrlChange(currentUrl);
            }
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        window.addEventListener('popstate', () => {
            this.handleUrlChange(window.location.href);
        });

        this.logger.log('å¯¼èˆªç›‘å¬å™¨å·²è®¾ç½®', 'info');
    }

    // å¤„ç†URLå˜åŒ–
    handleUrlChange(newUrl) {
        const newPath = new URL(newUrl).pathname;
        const oldPath = new URL(this.lastUrl).pathname;

        // åªæœ‰å½“pathnameçš„ä¸»ä½“éƒ¨åˆ†å‘ç”Ÿå˜åŒ–æ—¶ï¼Œæ‰è®¤ä¸ºæ˜¯çœŸæ­£çš„å¯¼èˆª
        const newPathBase = newPath.split('/').slice(0, 3).join('/');
        const oldPathBase = oldPath.split('/').slice(0, 3).join('/');

        if (newPathBase !== oldPathBase) {
            this.logger.log(`URL è·¯å¾„å‘ç”Ÿå˜åŒ–: ${newPath}`, 'info');
            this.lastUrl = newUrl;

            // åœæ­¢å½“å‰çš„æ´»åŠ¨
            if (this.isRunning) {
                this.stop();
            }

            // å»¶è¿Ÿåé‡æ–°å¯åŠ¨ï¼Œä»¥ç¡®ä¿é¡µé¢å†…å®¹å·²åŠ è½½
            setTimeout(() => {
                const pageInfo = this.siteAdapter.getPageInfo();
                if (pageInfo.isTopicPage) {
                    this.start();
                } else {
                    this.navigateToNextTopic();
                }
            }, 2000);
        }
    }

    // ç­‰å¾…DOMå‡†å¤‡å°±ç»ª
    async waitForDOM() {
      return new Promise((resolve) => {
        if (document.body && document.head) {
          resolve();
          return;
        }

        const observer = new MutationObserver(() => {
          if (document.body && document.head) {
            observer.disconnect();
            resolve();
          }
        });

        observer.observe(document.documentElement, {
          childList: true,
          subtree: true
        });

        // è¶…æ—¶ä¿æŠ¤
        setTimeout(() => {
          observer.disconnect();
          resolve();
        }, 5000);
      });
    }

    // å¼€å§‹è¿è¡Œ
    async start() {
      if (this.isRunning) return;

      this.isRunning = true;
      GM_setValue('isReading', true);

      // å®‰å…¨æ›´æ–°æ§åˆ¶é¢æ¿çŠ¶æ€
      try {
        if (this.controlPanel && typeof this.controlPanel.updateButtonStates === 'function') {
          this.controlPanel.updateButtonStates();
        }
      } catch (e) {
        console.error('æ›´æ–°æŒ‰é’®çŠ¶æ€å¤±è´¥:', e);
      }

      this.logger.log('å¼€å§‹è‡ªåŠ¨é˜…è¯»', 'success');
      this.statusIndicator.updateStatus('loading');

      // å¯åŠ¨è¡Œä¸ºæ¨¡æ‹Ÿ
      if (this.config.get('enableAdvancedBehavior')) {
        this.behaviorSimulator.start();
      }

      // å¯åŠ¨è‡ªåŠ¨åŒ–å¼•æ“
      if (this.config.get('autoReplyEnabled') || this.config.get('keywordMonitoring')) {
        this.automationEngine.start();
      }

      // å¼€å§‹ä¸»å¾ªç¯
      this.startMainLoop();

      // å¯åŠ¨å¡ä½æ£€æµ‹
      this.startStuckDetection();

      // å¦‚æœä¸åœ¨è¯é¢˜é¡µé¢ï¼Œå¯¼èˆªåˆ°è¯é¢˜
      const pageInfo = this.siteAdapter.getPageInfo();
      if (!pageInfo.isTopicPage) {
        await this.navigateToNextTopic();
      } else {
        this.startTopicReading();
      }
    }

    // åœæ­¢è¿è¡Œ
    stop() {
      if (!this.isRunning) return;

      this.isRunning = false;
      GM_setValue('isReading', false);

      // å®‰å…¨æ›´æ–°æ§åˆ¶é¢æ¿çŠ¶æ€
      try {
        if (this.controlPanel && typeof this.controlPanel.updateButtonStates === 'function') {
          this.controlPanel.updateButtonStates();
        }
      } catch (e) {
        console.error('æ›´æ–°æŒ‰é’®çŠ¶æ€å¤±è´¥:', e);
      }

      this.logger.log('åœæ­¢è‡ªåŠ¨é˜…è¯»', 'action');
      this.statusIndicator.updateStatus('idle');

      // åœæ­¢æ‰€æœ‰ç»„ä»¶
      this.scrollSystem.stopScrolling();
      this.behaviorSimulator.stop();
      this.automationEngine.stop();

      // æ¸…ç†å®šæ—¶å™¨
      if (this.mainLoop) {
        clearTimeout(this.mainLoop);
        this.mainLoop = null;
      }

      if (this.stuckCheckInterval) {
        clearInterval(this.stuckCheckInterval);
        this.stuckCheckInterval = null;
      }

      // ç»“æŸä¼šè¯åˆ†æ
      try {
        const report = this.dataAnalyzer.endSession();
        this.logger.log(`ä¼šè¯æŠ¥å‘Š: é˜…è¯»${report.session.topicsRead}ä¸ªè¯é¢˜`, 'info');
      } catch (e) {
        console.error('ç”Ÿæˆä¼šè¯æŠ¥å‘Šå¤±è´¥:', e);
      }
    }

    // å¼€å§‹ä¸»å¾ªç¯
    startMainLoop() {
      const checkInterval = 3000; // 3ç§’æ£€æŸ¥ä¸€æ¬¡

      const mainCheck = async () => {
        if (!this.isRunning) return;

        try {
          await this.performMainCheck();
        } catch (error) {
          this.logger.log(`ä¸»å¾ªç¯é”™è¯¯: ${error.message}`, 'error');
          this.dataAnalyzer.recordErrorEvent('main_loop', error.message, 'main_check');
        }

        // å®‰æ’ä¸‹æ¬¡æ£€æŸ¥
        this.mainLoop = setTimeout(mainCheck, checkInterval);
      };

      mainCheck();
    }

    // æ‰§è¡Œä¸»è¦æ£€æŸ¥
    async performMainCheck() {
      const now = Date.now();
      const readDuration = now - this.topicStartTime;
      const maxIdleTime = Math.max(this.config.get('maxIdleTime'), this.requiredReadTime);

      // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ¢è¯é¢˜
      if (this.shouldSwitchTopic(readDuration, maxIdleTime)) {
        await this.navigateToNextTopic();
        return;
      }

      // æ‰§è¡Œæ»šåŠ¨
      if (!this.scrollSystem.isScrolling) {
        const scrollSuccess = await this.scrollSystem.performIntelligentScroll();
        if (scrollSuccess) {
          this.dataAnalyzer.recordScrollEvent(
            this.scrollSystem.scrollDirection,
            this.config.get('scrollSegmentDistanceMin'),
            this.config.get('scrollSegmentDurationMin')
          );
        }
      }

      // æ‰§è¡Œç‚¹èµ
      if (GM_getValue('autoLikeEnabled', false)) {
        await this.performAutoLike();
      }

      // å®‰å…¨æ··æ·†
      if (Math.random() < 0.1) {
        this.securityManager.obfuscateBehavior();
      }
    }

    // åˆ¤æ–­æ˜¯å¦åº”è¯¥åˆ‡æ¢è¯é¢˜
    shouldSwitchTopic(readDuration, maxIdleTime) {
      const documentHeight = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
      const windowHeight = window.innerHeight;
      const currentY = window.scrollY;
      const isAtBottom = currentY + windowHeight >= documentHeight - 10;
      const isAtTop = currentY <= 10;

      // è¶…æ—¶åˆ‡æ¢
      if (readDuration > maxIdleTime) {
        this.logger.log(`é˜…è¯»è¶…æ—¶ (${Utils.formatTime(readDuration)})ï¼Œåˆ‡æ¢è¯é¢˜`, 'info');
        return true;
      }

      // è¾¾åˆ°æœ€å°é˜…è¯»æ—¶é—´ä¸”åœ¨é¡µé¢è¾¹ç•Œ
      if (readDuration >= this.requiredReadTime && (isAtBottom || isAtTop)) {
        this.logger.log(`é˜…è¯»å®Œæˆ (${Utils.formatTime(readDuration)})ï¼Œåˆ‡æ¢è¯é¢˜`, 'info');
        return true;
      }

      return false;
    }

    // å¯¼èˆªåˆ°ä¸‹ä¸€ä¸ªè¯é¢˜
    async navigateToNextTopic() {
      this.statusIndicator.updateStatus('switching');

      try {
        // è®°å½•å½“å‰è¯é¢˜çš„é˜…è¯»æ•°æ®
        if (this.currentTopic) {
          const readTime = Date.now() - this.topicStartTime;
          this.dataAnalyzer.recordTopicVisit(
            this.currentTopic.id,
            this.currentTopic.title || document.title,
            this.currentTopic.category,
            readTime
          );
          this.logger.updateStatistics('topicsRead');
        }

        // è·å–ä¸‹ä¸€ä¸ªè¯é¢˜
        const nextTopic = await this.getNextTopic();
        if (!nextTopic) {
          this.logger.log('æ²¡æœ‰æ›´å¤šè¯é¢˜ï¼Œåœæ­¢è¿è¡Œ', 'warn');
          this.stop();
          return;
        }

        // éšæœºå»¶è¿Ÿ
        const delay = Utils.getRandomInt(
          this.config.get('minTopicChangeDelay'),
          this.config.get('maxTopicChangeDelay')
        );

        this.logger.log(`ç­‰å¾… ${Utils.formatTime(delay)} ååˆ‡æ¢åˆ°è¯é¢˜: ${nextTopic.title || nextTopic.id}`, 'info');
        await Utils.sleep(delay);

        // å¯¼èˆªåˆ°æ–°è¯é¢˜
        const topicUrl = this.siteAdapter.buildTopicUrl(nextTopic.id, nextTopic.last_read_post_number || 1);

        // åœ¨å½“å‰æ ‡ç­¾é¡µä¸­å¯¼èˆª
        window.location.href = topicUrl;

      } catch (error) {
        this.logger.log(`è¯é¢˜åˆ‡æ¢å¤±è´¥: ${error.message}`, 'error');
        this.dataAnalyzer.recordErrorEvent('topic_switch', error.message, 'navigation');

        // é‡è¯•
        setTimeout(() => this.navigateToNextTopic(), 10000);
      }
    }

    // å¼€å§‹è¯é¢˜é˜…è¯»
    startTopicReading() {
      const pageInfo = this.siteAdapter.getPageInfo();
      this.currentTopic = {
        id: pageInfo.topicId,
        title: pageInfo.title,
        url: pageInfo.url
      };

      this.topicStartTime = Date.now();
      this.requiredReadTime = Utils.getRandomInt(
        this.config.get('minReadTimeLower'),
        this.config.get('minReadTimeUpper')
      );

      this.scrollSystem.scrollDirection = 'down';
      this.statusIndicator.updateStatus('reading');

      this.logger.log(`å¼€å§‹é˜…è¯»è¯é¢˜: ${this.currentTopic.title} (éœ€è¦ ${Utils.formatTime(this.requiredReadTime)})`, 'info');
    }

    // è·å–ä¸‹ä¸€ä¸ªè¯é¢˜
    async getNextTopic() {
      // å°è¯•ä»ç¼“å­˜è·å–
      let topicList = GM_getValue('topicList', '[]');
      try {
        topicList = JSON.parse(topicList);
      } catch (e) {
        topicList = [];
      }

      if (topicList.length === 0) {
        // è·å–æ–°è¯é¢˜
        this.logger.log('è¯é¢˜åˆ—è¡¨ä¸ºç©ºï¼Œè·å–æ–°è¯é¢˜...', 'info');
        const newTopics = await this.fetchTopics();
        if (newTopics.length === 0) {
          return null;
        }
        topicList = newTopics;
        GM_setValue('topicList', JSON.stringify(topicList));
      }

      // è¿”å›ç¬¬ä¸€ä¸ªè¯é¢˜å¹¶ä»åˆ—è¡¨ä¸­ç§»é™¤
      const nextTopic = topicList.shift();
      GM_setValue('topicList', JSON.stringify(topicList));

      return nextTopic;
    }

    // è·å–è¯é¢˜åˆ—è¡¨
    async fetchTopics() {
      const topics = [];
      const maxRetries = 3;
      let page = GM_getValue('latestPage', 0);

      for (let retry = 0; retry < maxRetries; retry++) {
        try {
          page++;
          const pageTopics = await this.siteAdapter.fetchTopics(page);

          if (pageTopics.length > 0) {
            topics.push(...pageTopics);
            GM_setValue('latestPage', page);

            if (topics.length >= this.config.get('topicListLimit')) {
              break;
            }
          } else {
            // æ²¡æœ‰æ›´å¤šè¯é¢˜ï¼Œé‡ç½®é¡µç 
            GM_setValue('latestPage', 0);
            break;
          }
        } catch (error) {
          this.logger.log(`è·å–è¯é¢˜å¤±è´¥ (é¡µé¢ ${page}): ${error.message}`, 'error');
          await Utils.sleep(1000);
        }
      }

      this.logger.log(`è·å–åˆ° ${topics.length} ä¸ªè¯é¢˜`, 'success');
      return topics.slice(0, this.config.get('topicListLimit'));
    }

    // æ£€æµ‹æ˜¯å¦æœ‰å¼¹çª—å‡ºç°
    checkForPopups() {
      // éœ€è¦å¿½ç•¥çš„å¼¹çª—ç±»å‹ï¼ˆä¿¡æ¯æ€§å¼¹çª—ï¼Œä¸åº”åœæ­¢ç‚¹èµï¼‰
      const ignoredPopupSelectors = [
        '.user-card',           // ç”¨æˆ·ä¿¡æ¯å¡ç‰‡
        '.user-tooltip',        // ç”¨æˆ·æç¤ºæ¡†
        '.topic-entrance',      // è¯é¢˜å…¥å£
        '.quote-button',        // å¼•ç”¨æŒ‰é’®
        '.post-menu',          // å¸–å­èœå•
        '.dropdown-menu',      // ä¸‹æ‹‰èœå•
        '.autocomplete',       // è‡ªåŠ¨å®Œæˆ
        '.suggestion-menu',    // å»ºè®®èœå•
        '.emoji-picker',       // è¡¨æƒ…é€‰æ‹©å™¨
        '.preview-popup'       // é¢„è§ˆå¼¹çª—
      ];

      // éœ€è¦æ£€æµ‹çš„å¼¹çª—é€‰æ‹©å™¨ï¼ˆä¼šé˜»æ­¢æ“ä½œçš„å¼¹çª—ï¼‰
      const criticalPopupSelectors = [
        '.modal', '.popup', '.dialog', '.overlay',
        '.alert', '.notification', '.toast',
        '[role="dialog"]', '[role="alertdialog"]',
        '.swal2-container', '.sweetalert2-container',
        '.layui-layer', '.layer-shade',
        '.ant-modal', '.el-dialog',
        '.v-dialog', '.q-dialog',
        // NodeLoc ç‰¹å®šçš„é‡è¦å¼¹çª—
        '.fancybox-container', '.fancybox-overlay',
        '.ui-dialog', '.ui-widget-overlay',
        '.bootbox', '.confirm-dialog',
        '.error-dialog', '.warning-dialog'
      ];

      // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯åº”è¯¥å¿½ç•¥çš„å¼¹çª—
      for (const selector of ignoredPopupSelectors) {
        const popup = document.querySelector(selector);
        if (popup && this.isElementVisible(popup)) {
          // è¿™æ˜¯ä¿¡æ¯æ€§å¼¹çª—ï¼Œä¸éœ€è¦åœæ­¢ç‚¹èµ
          return null;
        }
      }

      // æ£€æŸ¥å…³é”®å¼¹çª—
      for (const selector of criticalPopupSelectors) {
        const popup = document.querySelector(selector);
        if (popup && this.isElementVisible(popup)) {
          return popup;
        }
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰é®ç½©å±‚ï¼ˆä½†æ’é™¤ç”¨æˆ·å¡ç‰‡ç›¸å…³çš„ï¼‰
      const overlays = document.querySelectorAll('div[style*="position: fixed"], div[style*="position:fixed"]');
      for (const overlay of overlays) {
        // è·³è¿‡ç”¨æˆ·å¡ç‰‡ç›¸å…³çš„é®ç½©
        if (overlay.id === 'user-card' ||
            overlay.classList.contains('user-card') ||
            overlay.closest('.user-card')) {
          continue;
        }

        const style = getComputedStyle(overlay);
        if (style.zIndex > 1000 &&
            (style.backgroundColor !== 'rgba(0, 0, 0, 0)' ||
             style.background !== 'none')) {
          return overlay;
        }
      }

      return null;
    }

    // æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯è§
    isElementVisible(element) {
      if (!element) return false;

      const style = getComputedStyle(element);
      return element.style.display !== 'none' &&
             style.display !== 'none' &&
             style.visibility !== 'hidden' &&
             style.opacity !== '0';
    }

    // å¯åŠ¨å¼¹çª—ç›‘æ§
    startPopupMonitoring() {
      // ä½¿ç”¨ MutationObserver ç›‘æ§ DOM å˜åŒ–
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              this.checkNewElementForPopup(node);
            }
          });
        });
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true
      });

      // å®šæœŸæ£€æŸ¥å¼¹çª—
      setInterval(() => {
        this.performPopupCheck();
      }, 3000); // æ¯3ç§’æ£€æŸ¥ä¸€æ¬¡

      this.logger.log('å¼¹çª—ç›‘æ§å·²å¯åŠ¨', 'info');
    }

    // æ£€æŸ¥æ–°å…ƒç´ æ˜¯å¦ä¸ºå¼¹çª—
    checkNewElementForPopup(element) {
      const popupClasses = [
        'modal', 'popup', 'dialog', 'overlay', 'alert', 'notification', 'toast',
        'swal2-container', 'sweetalert2-container', 'layui-layer', 'layer-shade',
        'ant-modal', 'el-dialog', 'v-dialog', 'q-dialog',
        'fancybox-container', 'fancybox-overlay', 'ui-dialog', 'ui-widget-overlay'
      ];

      const hasPopupClass = popupClasses.some(className =>
        element.classList && element.classList.contains(className)
      );

      const hasPopupRole = element.getAttribute &&
        (element.getAttribute('role') === 'dialog' ||
         element.getAttribute('role') === 'alertdialog');

      if (hasPopupClass || hasPopupRole) {
        setTimeout(() => {
          this.handlePopupDetected(element);
        }, 500); // å»¶è¿Ÿ500msç¡®ä¿å¼¹çª—å®Œå…¨æ˜¾ç¤º
      }
    }

    // å®šæœŸæ‰§è¡Œå¼¹çª—æ£€æŸ¥
    performPopupCheck() {
      const popup = this.checkForPopups();
      if (popup) {
        this.handlePopupDetected(popup);
      }
    }

    // å¤„ç†æ£€æµ‹åˆ°çš„å¼¹çª—
    handlePopupDetected(popup) {
      const isLikeEnabled = GM_getValue('autoLikeEnabled', false);

      if (isLikeEnabled) {
        this.logger.log('ğŸš¨ æ£€æµ‹åˆ°å¼¹çª—ï¼Œè‡ªåŠ¨åœæ­¢ç‚¹èµåŠŸèƒ½', 'warning');
        GM_setValue('autoLikeEnabled', false);

        // æ›´æ–°æ§åˆ¶é¢æ¿æŒ‰é’®çŠ¶æ€
        if (this.controlPanel && typeof this.controlPanel.updateButtonStates === 'function') {
          this.controlPanel.updateButtonStates();
        }

        // æ˜¾ç¤ºé€šçŸ¥
        this.logger.showNotification('æ£€æµ‹åˆ°å¼¹çª—ï¼Œå·²è‡ªåŠ¨åœæ­¢ç‚¹èµåŠŸèƒ½', 'warning');

        // è®°å½•å¼¹çª—ä¿¡æ¯
        const popupInfo = {
          className: popup.className || '',
          id: popup.id || '',
          tagName: popup.tagName || '',
          timestamp: new Date().toLocaleString()
        };

        this.logger.log(`å¼¹çª—è¯¦æƒ…: ${JSON.stringify(popupInfo)}`, 'info');
      }
    }

    // å¯åŠ¨ç½‘ç»œè¯·æ±‚ç›‘æ§
    startNetworkMonitoring() {
      // ç›‘æ§ XMLHttpRequest
      const originalXHROpen = XMLHttpRequest.prototype.open;
      const originalXHRSend = XMLHttpRequest.prototype.send;

      XMLHttpRequest.prototype.open = function(method, url, ...args) {
        this._method = method;
        this._url = url;
        return originalXHROpen.apply(this, [method, url, ...args]);
      };

      XMLHttpRequest.prototype.send = function(data) {
        const xhr = this;

        // ç›‘å¬å“åº”
        xhr.addEventListener('readystatechange', () => {
          if (xhr.readyState === 4) {
            this.handleNetworkResponse(xhr._method, xhr._url, xhr.status, xhr.responseText);
          }
        });

        return originalXHRSend.apply(this, [data]);
      }.bind(this);

      // ç›‘æ§ fetch è¯·æ±‚
      const originalFetch = window.fetch;
      window.fetch = async function(url, options = {}) {
        const method = options.method || 'GET';

        try {
          const response = await originalFetch.apply(this, [url, options]);

          // æ£€æŸ¥å“åº”
          if (response.status === 429) {
            const responseText = await response.clone().text();
            this.handleNetworkResponse(method, url, response.status, responseText);
          }

          return response;
        } catch (error) {
          return Promise.reject(error);
        }
      }.bind(this);

      this.logger.log('ç½‘ç»œè¯·æ±‚ç›‘æ§å·²å¯åŠ¨', 'info');
    }

    // å¤„ç†ç½‘ç»œå“åº”
    handleNetworkResponse(method, url, status, responseText) {
      // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¹èµç›¸å…³çš„è¯·æ±‚
      const isLikeRequest = url && (
        url.includes('discourse-reactions') ||
        url.includes('custom-reactions') ||
        url.includes('/like') ||
        url.includes('/heart') ||
        url.includes('/toggle')
      );

      if (isLikeRequest && status === 429) {
        this.handleRateLimitError(responseText);
      }
    }

    // å¤„ç†ç‚¹èµé™åˆ¶é”™è¯¯
    handleRateLimitError(responseText) {
      try {
        const errorData = JSON.parse(responseText);

        if (errorData.errors && errorData.errors.length > 0) {
          const errorMessage = errorData.errors[0];
          const timeLeft = errorData.extras?.time_left || 'æœªçŸ¥';
          const waitSeconds = errorData.extras?.wait_seconds || 0;

          this.logger.log(`ğŸš« ç‚¹èµé™åˆ¶è§¦å‘`, 'error');
          this.logger.log(`ğŸ“ é™åˆ¶è¯¦æƒ…: ${errorMessage}`, 'error');
          this.logger.log(`â° å‰©ä½™ç­‰å¾…æ—¶é—´: ${timeLeft}`, 'warning');

          // è®¡ç®—å…·ä½“å¯ç‚¹èµæ—¶é—´
          if (waitSeconds > 0) {
            const canLikeTimestamp = Date.now() + (waitSeconds * 1000);
            const canLikeTime = new Date(canLikeTimestamp).toLocaleString('zh-CN', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit'
            });
            this.logger.log(`ğŸ“… é¢„è®¡å¯ç‚¹èµæ—¶é—´: ${canLikeTime}`, 'info');
          }

          // è‡ªåŠ¨åœæ­¢ç‚¹èµåŠŸèƒ½
          GM_setValue('autoLikeEnabled', false);

          // ä¿å­˜é™åˆ¶ä¿¡æ¯
          const rateLimitInfo = {
            message: errorMessage,
            timeLeft: timeLeft,
            waitSeconds: waitSeconds,
            timestamp: Date.now()
          };
          GM_setValue('rateLimitInfo', rateLimitInfo);

          // æ›´æ–°æ§åˆ¶é¢æ¿çŠ¶æ€
          if (this.controlPanel && typeof this.controlPanel.updateButtonStates === 'function') {
            this.controlPanel.updateButtonStates();
          }

          // æ˜¾ç¤ºé€šçŸ¥
          this.logger.showNotification(`ç‚¹èµå·²è¾¾é™åˆ¶ï¼Œéœ€ç­‰å¾… ${timeLeft}`, 'error');

          this.logger.log('ğŸ›‘ å·²è‡ªåŠ¨åœæ­¢ç‚¹èµåŠŸèƒ½ï¼Œé¿å…ç»§ç»­è§¦å‘é™åˆ¶', 'action');

          // æ˜¾ç¤ºè¯¦ç»†çš„é™åˆ¶ä¿¡æ¯æ‘˜è¦
          this.showRateLimitSummary(rateLimitInfo);
        }
      } catch (parseError) {
        this.logger.log('è§£æé™åˆ¶é”™è¯¯ä¿¡æ¯å¤±è´¥', 'error');

        // å³ä½¿è§£æå¤±è´¥ï¼Œä¹Ÿè¦åœæ­¢ç‚¹èµ
        GM_setValue('autoLikeEnabled', false);
        if (this.controlPanel && typeof this.controlPanel.updateButtonStates === 'function') {
          this.controlPanel.updateButtonStates();
        }
        this.logger.showNotification('æ£€æµ‹åˆ°ç‚¹èµé™åˆ¶ï¼Œå·²è‡ªåŠ¨åœæ­¢', 'warning');
      }
    }

    // æ˜¾ç¤ºé™åˆ¶ä¿¡æ¯æ‘˜è¦
    showRateLimitSummary(rateLimitInfo) {
      this.logger.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'info');
      this.logger.log('ğŸ“Š ç‚¹èµé™åˆ¶ä¿¡æ¯æ‘˜è¦', 'info');
      this.logger.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'info');

      const currentTime = new Date().toLocaleString('zh-CN');
      this.logger.log(`ğŸ• è§¦å‘æ—¶é—´: ${currentTime}`, 'info');

      if (rateLimitInfo.waitSeconds > 0) {
        const canLikeTime = this.getCanLikeTime(rateLimitInfo);
        this.logger.log(`ğŸ“… æ¢å¤æ—¶é—´: ${canLikeTime}`, 'info');

        // è®¡ç®—å…·ä½“çš„å°æ—¶å’Œåˆ†é’Ÿ
        const hours = Math.floor(rateLimitInfo.waitSeconds / 3600);
        const minutes = Math.floor((rateLimitInfo.waitSeconds % 3600) / 60);

        if (hours > 0) {
          this.logger.log(`â³ ç­‰å¾…æ—¶é•¿: ${hours}å°æ—¶${minutes}åˆ†é’Ÿ`, 'info');
        } else {
          this.logger.log(`â³ ç­‰å¾…æ—¶é•¿: ${minutes}åˆ†é’Ÿ`, 'info');
        }
      }

      this.logger.log(`ğŸ’¡ å»ºè®®: è¯·åœ¨æ¢å¤æ—¶é—´åé‡æ–°å¯ç”¨ç‚¹èµåŠŸèƒ½`, 'info');
      this.logger.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'info');
    }

    // è·å–å¯ä»¥ç‚¹èµçš„å…·ä½“æ—¶é—´
    getCanLikeTime(rateLimitInfo) {
      if (!rateLimitInfo || !rateLimitInfo.waitSeconds || !rateLimitInfo.timestamp) {
        return 'æœªçŸ¥';
      }

      const canLikeTimestamp = rateLimitInfo.timestamp + (rateLimitInfo.waitSeconds * 1000);
      const canLikeDate = new Date(canLikeTimestamp);

      return canLikeDate.toLocaleString('zh-CN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
    }

    // æ‰§è¡Œè‡ªåŠ¨ç‚¹èµ
    async performAutoLike() {
      if (!this.siteAdapter.hasFeature('reactions') && !this.siteAdapter.hasFeature('likes')) {
        return;
      }

      // æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†è‡ªåŠ¨ç‚¹èµ
      if (!GM_getValue('autoLikeEnabled', false)) {
        return;
      }

      // æ£€æŸ¥æ˜¯å¦åœ¨é™åˆ¶æœŸå†…
      const rateLimitInfo = GM_getValue('rateLimitInfo', null);
      if (rateLimitInfo && this.controlPanel.isRateLimitActive(rateLimitInfo)) {
        this.logger.log('ç‚¹èµä»åœ¨é™åˆ¶æœŸå†…ï¼Œè·³è¿‡è‡ªåŠ¨ç‚¹èµ', 'warning');
        return;
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰å¼¹çª—å‡ºç°
      const popup = this.checkForPopups();
      if (popup) {
        this.logger.log('æ£€æµ‹åˆ°å¼¹çª—ï¼Œè‡ªåŠ¨åœæ­¢ç‚¹èµåŠŸèƒ½', 'warning');
        GM_setValue('autoLikeEnabled', false);

        // æ›´æ–°æ§åˆ¶é¢æ¿æŒ‰é’®çŠ¶æ€
        if (this.controlPanel && typeof this.controlPanel.updateButtonStates === 'function') {
          this.controlPanel.updateButtonStates();
        }

        return;
      }

      const likeSelector = this.siteAdapter.getSelector('likeButton');
      if (!likeSelector) return;

      const likeButtons = document.querySelectorAll(likeSelector);
      const maxLikes = this.siteAdapter.getLimit('maxLikes');
      const currentLikes = GM_getValue('dailyLikeCount', 0);

      if (currentLikes >= maxLikes) {
        return;
      }

      for (const button of likeButtons) {
        if (currentLikes >= maxLikes) break;

        // åœ¨æ¯æ¬¡ç‚¹èµå‰å†æ¬¡æ£€æŸ¥å¼¹çª—
        const popupCheck = this.checkForPopups();
        if (popupCheck) {
          this.logger.log('ç‚¹èµè¿‡ç¨‹ä¸­æ£€æµ‹åˆ°å¼¹çª—ï¼Œåœæ­¢ç‚¹èµ', 'warning');
          GM_setValue('autoLikeEnabled', false);

          // æ›´æ–°æ§åˆ¶é¢æ¿æŒ‰é’®çŠ¶æ€
          if (this.controlPanel && typeof this.controlPanel.updateButtonStates === 'function') {
            this.controlPanel.updateButtonStates();
          }

          break;
        }

        const success = await this.siteAdapter.performLike(button);
        if (success) {
          GM_setValue('dailyLikeCount', currentLikes + 1);
          this.dataAnalyzer.recordLikeEvent(this.currentTopic?.id, null);
          this.logger.updateStatistics('likesGiven');
          this.logger.log(`ç‚¹èµæˆåŠŸ (${currentLikes + 1}/${maxLikes})`, 'success');

          // éšæœºå»¶è¿Ÿ
          await Utils.sleep(Utils.getRandomInt(2000, 5000));
        }
      }
    }

    // å¯åŠ¨å¡ä½æ£€æµ‹
    startStuckDetection() {
      this.stuckCheckInterval = setInterval(() => {
        if (!this.isRunning) return;

        if (this.scrollSystem.isStuck()) {
          this.logger.log('æ£€æµ‹åˆ°é¡µé¢å¡ä½ï¼Œå¼ºåˆ¶åˆ‡æ¢è¯é¢˜', 'warn');
          this.navigateToNextTopic();
        }
      }, this.config.get('stuckTimeout'));
    }
  }


  // ===== è‡ªåŠ¨åŒ–å¼•æ“ç±» =====
  class AutomationEngine {
    constructor(config, logger, siteAdapter) {
      this.config = config;
      this.logger = logger;
      this.siteAdapter = siteAdapter;
      this.isRunning = false;
      this.keywordPatterns = [];
      this.autoReplyTemplates = [];
      this.monitoringInterval = null;
      this.initializeTemplates();
    }

    // åˆå§‹åŒ–æ¨¡æ¿
    initializeTemplates() {
      this.autoReplyTemplates = [
        {
          trigger: ['è°¢è°¢', 'æ„Ÿè°¢', 'thanks', 'thank you'],
          responses: ['ä¸å®¢æ°”ï¼', 'å¾ˆé«˜å…´èƒ½å¸®åˆ°ä½ ï¼', 'äº’ç›¸å¸®åŠ©ï¼', 'ğŸ¤'],
          weight: 0.3
        },
        {
          trigger: ['é—®é¢˜', 'æ±‚åŠ©', 'help', 'question'],
          responses: ['æˆ‘æ¥çœ‹çœ‹èƒ½ä¸èƒ½å¸®åˆ°ä½ ', 'è¿™ä¸ªé—®é¢˜å¾ˆæœ‰æ„æ€', 'è®©æˆ‘æƒ³æƒ³...', 'å¯ä»¥è¯¦ç»†è¯´è¯´å—ï¼Ÿ'],
          weight: 0.2
        },
        {
          trigger: ['å¥½çš„', 'ä¸é”™', 'good', 'nice', 'èµ'],
          responses: ['ğŸ‘', 'åŒæ„Ÿï¼', 'ç¡®å®å¦‚æ­¤', 'è¯´å¾—å¯¹'],
          weight: 0.4
        },
        {
          trigger: ['æ•™ç¨‹', 'tutorial', 'æŒ‡å—', 'guide'],
          responses: ['å¾ˆå®ç”¨çš„æ•™ç¨‹ï¼', 'å­¦åˆ°äº†ï¼Œæ„Ÿè°¢åˆ†äº«', 'æ”¶è—äº†ï¼', 'è¿™ä¸ªæ•™ç¨‹å¾ˆè¯¦ç»†'],
          weight: 0.5
        }
      ];

      // åŠ è½½ç”¨æˆ·è‡ªå®šä¹‰å…³é”®è¯
      const customKeywords = this.config.get('monitorKeywords') || [];
      this.keywordPatterns = customKeywords.map(keyword => ({
        pattern: new RegExp(keyword, 'i'),
        keyword: keyword,
        action: this.config.get('keywordAction') || 'notify'
      }));
    }

    // å¯åŠ¨è‡ªåŠ¨åŒ–å¼•æ“
    start() {
      if (this.isRunning) return;

      this.isRunning = true;
      this.logger.log('è‡ªåŠ¨åŒ–å¼•æ“å·²å¯åŠ¨', 'success');

      // å¯åŠ¨å…³é”®è¯ç›‘æ§
      if (this.config.get('keywordMonitoring')) {
        this.startKeywordMonitoring();
      }

      // å¯åŠ¨è‡ªåŠ¨å›å¤ç›‘æ§
      if (this.config.get('autoReplyEnabled')) {
        this.startAutoReplyMonitoring();
      }
    }

    // åœæ­¢è‡ªåŠ¨åŒ–å¼•æ“
    stop() {
      if (!this.isRunning) return;

      this.isRunning = false;
      this.logger.log('è‡ªåŠ¨åŒ–å¼•æ“å·²åœæ­¢', 'action');

      if (this.monitoringInterval) {
        clearInterval(this.monitoringInterval);
        this.monitoringInterval = null;
      }
    }

    // å¯åŠ¨å…³é”®è¯ç›‘æ§
    startKeywordMonitoring() {
      this.monitoringInterval = setInterval(() => {
        this.scanForKeywords();
      }, 5000); // æ¯5ç§’æ‰«æä¸€æ¬¡

      this.logger.log(`å…³é”®è¯ç›‘æ§å·²å¯åŠ¨ï¼Œç›‘æ§ ${this.keywordPatterns.length} ä¸ªå…³é”®è¯`, 'info');
    }

    // æ‰«æå…³é”®è¯
    scanForKeywords() {
      if (!this.isRunning || this.keywordPatterns.length === 0) return;

      // è·å–é¡µé¢æ–‡æœ¬å†…å®¹
      const contentSelector = this.siteAdapter.getSelector('postContent') || 'article, .post, .content';
      const contentElements = document.querySelectorAll(contentSelector);

      contentElements.forEach((element, index) => {
        // é¿å…é‡å¤æ‰«æ
        if (element.dataset.scanned) return;
        element.dataset.scanned = 'true';

        const text = element.textContent.toLowerCase();

        this.keywordPatterns.forEach(({ pattern, keyword, action }) => {
          if (pattern.test(text)) {
            this.handleKeywordMatch(keyword, action, element, text);
          }
        });
      });
    }

    // å¤„ç†å…³é”®è¯åŒ¹é…
    async handleKeywordMatch(keyword, action, element, text) {
      this.logger.log(`æ£€æµ‹åˆ°å…³é”®è¯: ${keyword}`, 'success');

      switch (action) {
        case 'like':
          await this.performAutoLike(element);
          break;
        case 'reply':
          await this.performAutoReply(element, keyword);
          break;
        case 'notify':
          this.showKeywordNotification(keyword, text.substring(0, 100));
          break;
        case 'collect':
          await this.collectPost(element);
          break;
      }
    }

    // æ‰§è¡Œè‡ªåŠ¨ç‚¹èµï¼ˆå…³é”®è¯è§¦å‘ï¼‰
    async performAutoLike(element) {
      // æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†è‡ªåŠ¨ç‚¹èµ
      if (!GM_getValue('autoLikeEnabled', false)) {
        return;
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰å¼¹çª—å‡ºç°
      const popup = this.checkForPopups();
      if (popup) {
        this.logger.log('æ£€æµ‹åˆ°å¼¹çª—ï¼Œåœæ­¢å…³é”®è¯è§¦å‘çš„ç‚¹èµ', 'warning');
        GM_setValue('autoLikeEnabled', false);

        // æ›´æ–°æ§åˆ¶é¢æ¿æŒ‰é’®çŠ¶æ€
        if (this.controlPanel && typeof this.controlPanel.updateButtonStates === 'function') {
          this.controlPanel.updateButtonStates();
        }

        return;
      }

      const likeButton = element.querySelector(this.siteAdapter.getSelector('likeButton'));
      if (likeButton) {
        const success = await this.siteAdapter.performLike(likeButton);
        if (success) {
          this.logger.log('å…³é”®è¯è§¦å‘è‡ªåŠ¨ç‚¹èµ', 'success');
        }
      }
    }

    // æ£€æµ‹æ˜¯å¦æœ‰å¼¹çª—å‡ºç°ï¼ˆAutomationEngineç‰ˆæœ¬ï¼‰
    checkForPopups() {
      // éœ€è¦å¿½ç•¥çš„å¼¹çª—ç±»å‹ï¼ˆä¿¡æ¯æ€§å¼¹çª—ï¼Œä¸åº”åœæ­¢ç‚¹èµï¼‰
      const ignoredPopupSelectors = [
        '.user-card',           // ç”¨æˆ·ä¿¡æ¯å¡ç‰‡
        '.user-tooltip',        // ç”¨æˆ·æç¤ºæ¡†
        '.topic-entrance',      // è¯é¢˜å…¥å£
        '.quote-button',        // å¼•ç”¨æŒ‰é’®
        '.post-menu',          // å¸–å­èœå•
        '.dropdown-menu',      // ä¸‹æ‹‰èœå•
        '.autocomplete',       // è‡ªåŠ¨å®Œæˆ
        '.suggestion-menu',    // å»ºè®®èœå•
        '.emoji-picker',       // è¡¨æƒ…é€‰æ‹©å™¨
        '.preview-popup'       // é¢„è§ˆå¼¹çª—
      ];

      // éœ€è¦æ£€æµ‹çš„å¼¹çª—é€‰æ‹©å™¨ï¼ˆä¼šé˜»æ­¢æ“ä½œçš„å¼¹çª—ï¼‰
      const criticalPopupSelectors = [
        '.modal', '.popup', '.dialog', '.overlay',
        '.alert', '.notification', '.toast',
        '[role="dialog"]', '[role="alertdialog"]',
        '.swal2-container', '.sweetalert2-container',
        '.layui-layer', '.layer-shade',
        '.ant-modal', '.el-dialog',
        '.v-dialog', '.q-dialog',
        // NodeLoc ç‰¹å®šçš„é‡è¦å¼¹çª—
        '.fancybox-container', '.fancybox-overlay',
        '.ui-dialog', '.ui-widget-overlay',
        '.bootbox', '.confirm-dialog',
        '.error-dialog', '.warning-dialog'
      ];

      // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯åº”è¯¥å¿½ç•¥çš„å¼¹çª—
      for (const selector of ignoredPopupSelectors) {
        const popup = document.querySelector(selector);
        if (popup && this.isElementVisible(popup)) {
          // è¿™æ˜¯ä¿¡æ¯æ€§å¼¹çª—ï¼Œä¸éœ€è¦åœæ­¢ç‚¹èµ
          return null;
        }
      }

      // æ£€æŸ¥å…³é”®å¼¹çª—
      for (const selector of criticalPopupSelectors) {
        const popup = document.querySelector(selector);
        if (popup && this.isElementVisible(popup)) {
          return popup;
        }
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰é®ç½©å±‚ï¼ˆä½†æ’é™¤ç”¨æˆ·å¡ç‰‡ç›¸å…³çš„ï¼‰
      const overlays = document.querySelectorAll('div[style*="position: fixed"], div[style*="position:fixed"]');
      for (const overlay of overlays) {
        // è·³è¿‡ç”¨æˆ·å¡ç‰‡ç›¸å…³çš„é®ç½©
        if (overlay.id === 'user-card' ||
            overlay.classList.contains('user-card') ||
            overlay.closest('.user-card')) {
          continue;
        }

        const style = getComputedStyle(overlay);
        if (style.zIndex > 1000 &&
            (style.backgroundColor !== 'rgba(0, 0, 0, 0)' ||
             style.background !== 'none')) {
          return overlay;
        }
      }

      return null;
    }

    // æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯è§
    isElementVisible(element) {
      if (!element) return false;

      const style = getComputedStyle(element);
      return element.style.display !== 'none' &&
             style.display !== 'none' &&
             style.visibility !== 'hidden' &&
             style.opacity !== '0';
    }

    // æ‰§è¡Œè‡ªåŠ¨å›å¤
    async performAutoReply(element, keyword) {
      if (!this.siteAdapter.hasFeature('replies')) return;

      const replyButton = element.querySelector(this.siteAdapter.getSelector('replyButton'));
      if (!replyButton) return;

      // ç”Ÿæˆå›å¤å†…å®¹
      const replyContent = this.generateReplyContent(keyword);
      if (!replyContent) return;

      try {
        // ç‚¹å‡»å›å¤æŒ‰é’®
        replyButton.click();

        // ç­‰å¾…å›å¤æ¡†å‡ºç°
        await Utils.sleep(1000);

        // æŸ¥æ‰¾å›å¤è¾“å…¥æ¡†
        const replyInput = document.querySelector('textarea[placeholder*="å›å¤"], .reply-area textarea, .composer-input');
        if (replyInput) {
          // æ¨¡æ‹Ÿè¾“å…¥
          await this.simulateTyping(replyInput, replyContent);

          // æŸ¥æ‰¾å‘é€æŒ‰é’®
          const sendButton = document.querySelector('.btn-primary[title*="å‘é€"], .submit-reply, .create');
          if (sendButton && !sendButton.disabled) {
            // éšæœºå»¶è¿Ÿåå‘é€
            await Utils.sleep(Utils.getRandomInt(2000, 5000));
            sendButton.click();

            this.logger.log(`è‡ªåŠ¨å›å¤: ${replyContent}`, 'success');
          }
        }
      } catch (error) {
        this.logger.log(`è‡ªåŠ¨å›å¤å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // ç”Ÿæˆå›å¤å†…å®¹
    generateReplyContent(keyword) {
      const matchingTemplates = this.autoReplyTemplates.filter(template =>
        template.trigger.some(trigger => keyword.toLowerCase().includes(trigger.toLowerCase()))
      );

      if (matchingTemplates.length === 0) {
        // ä½¿ç”¨é€šç”¨å›å¤
        const genericReplies = ['ğŸ‘', 'æœ‰é“ç†', 'å­¦ä¹ äº†', 'æ„Ÿè°¢åˆ†äº«'];
        return genericReplies[Math.floor(Math.random() * genericReplies.length)];
      }

      // æ ¹æ®æƒé‡é€‰æ‹©æ¨¡æ¿
      const totalWeight = matchingTemplates.reduce((sum, t) => sum + t.weight, 0);
      let random = Math.random() * totalWeight;

      for (const template of matchingTemplates) {
        random -= template.weight;
        if (random <= 0) {
          const responses = template.responses;
          return responses[Math.floor(Math.random() * responses.length)];
        }
      }

      return null;
    }

    // æ¨¡æ‹Ÿæ‰“å­—
    async simulateTyping(input, text) {
      input.focus();
      input.value = '';

      // é€å­—ç¬¦è¾“å…¥
      for (let i = 0; i < text.length; i++) {
        input.value += text[i];

        // è§¦å‘è¾“å…¥äº‹ä»¶
        const inputEvent = new Event('input', { bubbles: true });
        input.dispatchEvent(inputEvent);

        // éšæœºå»¶è¿Ÿ
        await Utils.sleep(Utils.getRandomInt(50, 150));
      }

      // è§¦å‘æœ€ç»ˆäº‹ä»¶
      const changeEvent = new Event('change', { bubbles: true });
      input.dispatchEvent(changeEvent);
    }

    // æ˜¾ç¤ºå…³é”®è¯é€šçŸ¥
    showKeywordNotification(keyword, context) {
      if (typeof GM_notification !== 'undefined') {
        GM_notification({
          text: `æ£€æµ‹åˆ°å…³é”®è¯: ${keyword}\n${context}...`,
          title: 'æ™ºèƒ½è®ºå›åŠ©æ‰‹',
          timeout: 5000,
          onclick: () => {
            window.focus();
          }
        });
      }
    }

    // æ”¶è—å¸–å­
    async collectPost(element) {
      // æŸ¥æ‰¾æ”¶è—æŒ‰é’®
      const bookmarkButton = element.querySelector('.bookmark, [title*="æ”¶è—"], [data-action="bookmark"]');
      if (bookmarkButton && !bookmarkButton.classList.contains('bookmarked')) {
        bookmarkButton.click();
        this.logger.log('è‡ªåŠ¨æ”¶è—å¸–å­', 'success');
        await Utils.sleep(1000);
      }
    }

    // å¯åŠ¨è‡ªåŠ¨å›å¤ç›‘æ§
    startAutoReplyMonitoring() {
      // ç›‘æ§æ–°å¸–å­
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              this.scanNewContent(node);
            }
          });
        });
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true
      });

      this.logger.log('è‡ªåŠ¨å›å¤ç›‘æ§å·²å¯åŠ¨', 'info');
    }

    // æ‰«ææ–°å†…å®¹
    scanNewContent(element) {
      if (!this.isRunning) return;

      // æ£€æŸ¥æ˜¯å¦ä¸ºå¸–å­å†…å®¹
      const postSelectors = ['.post', '.topic-post', '.cooked', 'article'];
      const isPost = postSelectors.some(selector =>
        element.matches && element.matches(selector)
      );

      if (isPost) {
        const text = element.textContent.toLowerCase();

        // æ£€æŸ¥æ˜¯å¦åº”è¯¥è‡ªåŠ¨å›å¤
        const shouldReply = this.autoReplyTemplates.some(template =>
          template.trigger.some(trigger => text.includes(trigger.toLowerCase()))
        );

        if (shouldReply && Math.random() < 0.3) { // 30%æ¦‚ç‡å›å¤
          setTimeout(() => {
            this.performAutoReply(element, text);
          }, Utils.getRandomInt(5000, 15000)); // 5-15ç§’åå›å¤
        }
      }
    }

    // æ™ºèƒ½äº’åŠ¨
    async performSmartInteraction() {
      const interactions = [
        () => this.likeRandomPosts(),
        () => this.followInterestingUsers(),
        () => this.bookmarkUsefulContent(),
        () => this.shareContent()
      ];

      const randomInteraction = interactions[Math.floor(Math.random() * interactions.length)];
      await randomInteraction();
    }

    // ç‚¹èµéšæœºå¸–å­
    async likeRandomPosts() {
      // æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†è‡ªåŠ¨ç‚¹èµ
      if (!GM_getValue('autoLikeEnabled', false)) {
        return;
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰å¼¹çª—å‡ºç°
      const popup = this.checkForPopups();
      if (popup) {
        this.logger.log('æ£€æµ‹åˆ°å¼¹çª—ï¼Œåœæ­¢éšæœºç‚¹èµ', 'warning');
        GM_setValue('autoLikeEnabled', false);

        // æ›´æ–°æ§åˆ¶é¢æ¿æŒ‰é’®çŠ¶æ€
        if (this.controlPanel && typeof this.controlPanel.updateButtonStates === 'function') {
          this.controlPanel.updateButtonStates();
        }

        return;
      }

      const likeButtons = document.querySelectorAll(this.siteAdapter.getSelector('likeButton'));
      const maxLikes = Math.min(3, likeButtons.length);

      for (let i = 0; i < maxLikes; i++) {
        // åœ¨æ¯æ¬¡ç‚¹èµå‰æ£€æŸ¥å¼¹çª—
        const popupCheck = this.checkForPopups();
        if (popupCheck) {
          this.logger.log('éšæœºç‚¹èµè¿‡ç¨‹ä¸­æ£€æµ‹åˆ°å¼¹çª—ï¼Œåœæ­¢ç‚¹èµ', 'warning');
          GM_setValue('autoLikeEnabled', false);

          // æ›´æ–°æ§åˆ¶é¢æ¿æŒ‰é’®çŠ¶æ€
          if (this.controlPanel && typeof this.controlPanel.updateButtonStates === 'function') {
            this.controlPanel.updateButtonStates();
          }

          break;
        }

        const randomButton = likeButtons[Math.floor(Math.random() * likeButtons.length)];
        if (randomButton) {
          await this.siteAdapter.performLike(randomButton);
          await Utils.sleep(Utils.getRandomInt(2000, 5000));
        }
      }
    }

    // å…³æ³¨æœ‰è¶£çš„ç”¨æˆ·
    async followInterestingUsers() {
      const userLinks = document.querySelectorAll('a[href*="/u/"], .user-link');
      if (userLinks.length > 0 && Math.random() < 0.1) { // 10%æ¦‚ç‡
        const randomUser = userLinks[Math.floor(Math.random() * userLinks.length)];
        // è¿™é‡Œå¯ä»¥æ·»åŠ å…³æ³¨é€»è¾‘
        this.logger.log('å‘ç°æœ‰è¶£ç”¨æˆ·', 'info');
      }
    }

    // æ”¶è—æœ‰ç”¨å†…å®¹
    async bookmarkUsefulContent() {
      const usefulKeywords = ['æ•™ç¨‹', 'æŒ‡å—', 'æŠ€å·§', 'tutorial', 'guide', 'tip'];
      const posts = document.querySelectorAll('.post, .topic-post');

      posts.forEach(async (post) => {
        const text = post.textContent.toLowerCase();
        const isUseful = usefulKeywords.some(keyword => text.includes(keyword));

        if (isUseful && Math.random() < 0.2) { // 20%æ¦‚ç‡æ”¶è—
          await this.collectPost(post);
        }
      });
    }

    // åˆ†äº«å†…å®¹
    async shareContent() {
      // æŸ¥æ‰¾åˆ†äº«æŒ‰é’®
      const shareButtons = document.querySelectorAll('.share, [title*="åˆ†äº«"], [data-action="share"]');
      if (shareButtons.length > 0 && Math.random() < 0.05) { // 5%æ¦‚ç‡åˆ†äº«
        const randomShare = shareButtons[Math.floor(Math.random() * shareButtons.length)];
        randomShare.click();
        this.logger.log('åˆ†äº«æœ‰è¶£å†…å®¹', 'action');
      }
    }
  }

  // ===== æ¯æ—¥ä»»åŠ¡ç®¡ç†å™¨ =====
  class DailyTaskManager {
    constructor(config, logger, forumAssistant) {
      this.config = config;
      this.logger = logger;
      this.forumAssistant = forumAssistant;
      this.checkInterval = null;
    }

    // å¯åŠ¨æ¯æ—¥ä»»åŠ¡æ£€æŸ¥
    start() {
      // ç«‹å³æ£€æŸ¥ä¸€æ¬¡
      this.checkDailyTasks();

      // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
      this.checkInterval = setInterval(() => {
        this.checkDailyTasks();
      }, 60000);

      this.logger.log('æ¯æ—¥ä»»åŠ¡ç®¡ç†å™¨å·²å¯åŠ¨', 'info');
    }

    // åœæ­¢æ¯æ—¥ä»»åŠ¡æ£€æŸ¥
    stop() {
      if (this.checkInterval) {
        clearInterval(this.checkInterval);
        this.checkInterval = null;
      }
    }

    // æ£€æŸ¥æ¯æ—¥ä»»åŠ¡
    checkDailyTasks() {
      const now = new Date();
      const today = now.toISOString().split('T')[0];
      const lastRunDate = GM_getValue('dailyTaskLastRunDate', '');

      // æ£€æŸ¥æ˜¯å¦ä¸ºæ–°çš„ä¸€å¤©
      if (lastRunDate !== today) {
        this.resetDailyCounters();
        GM_setValue('dailyTaskLastRunDate', today);
      }

      // æ£€æŸ¥æ˜¯å¦åœ¨è‡ªåŠ¨å¯åŠ¨æ—¶é—´èŒƒå›´å†… (00:10-00:15)
      if (now.getHours() === 0 && now.getMinutes() >= 10 && now.getMinutes() < 15) {
        const autoStarted = GM_getValue('autoStartedToday', false);
        if (!autoStarted) {
          this.performDailyAutoStart();
          GM_setValue('autoStartedToday', true);
        }
      }

      // é‡ç½®è‡ªåŠ¨å¯åŠ¨æ ‡å¿—ï¼ˆåœ¨éå¯åŠ¨æ—¶é—´ï¼‰
      if (now.getHours() !== 0 || now.getMinutes() < 10 || now.getMinutes() >= 15) {
        GM_setValue('autoStartedToday', false);
      }
    }

    // é‡ç½®æ¯æ—¥è®¡æ•°å™¨
    resetDailyCounters() {
      GM_setValue('dailyLikeCount', 0);
      GM_setValue('dailyTopicsRead', 0);
      GM_setValue('dailyErrors', 0);

      this.logger.log('æ¯æ—¥è®¡æ•°å™¨å·²é‡ç½®', 'action');
    }

    // æ‰§è¡Œæ¯æ—¥è‡ªåŠ¨å¯åŠ¨
    performDailyAutoStart() {
      this.logger.log('æ‰§è¡Œæ¯æ—¥è‡ªåŠ¨å¯åŠ¨ä»»åŠ¡', 'success');

      try {
        // å¯ç”¨è‡ªåŠ¨ç‚¹èµ
        GM_setValue('autoLikeEnabled', true);

        // å¯åŠ¨è®ºå›åŠ©æ‰‹
        if (!this.forumAssistant.isRunning) {
          setTimeout(() => {
            this.forumAssistant.start();
          }, Utils.getRandomInt(5000, 15000)); // 5-15ç§’åå¯åŠ¨
        }

        this.logger.log('æ¯æ—¥è‡ªåŠ¨å¯åŠ¨å®Œæˆ', 'success');

      } catch (error) {
        this.logger.log(`æ¯æ—¥è‡ªåŠ¨å¯åŠ¨å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // è·å–æ¯æ—¥ç»Ÿè®¡
    getDailyStats() {
      return {
        likesGiven: GM_getValue('dailyLikeCount', 0),
        topicsRead: GM_getValue('dailyTopicsRead', 0),
        errors: GM_getValue('dailyErrors', 0),
        date: new Date().toISOString().split('T')[0]
      };
    }
  }

  // ===== å…¨å±€å˜é‡å’Œåˆå§‹åŒ– =====
  let forumAssistant = null;
  let dailyTaskManager = null;

  // ===== å®‰å…¨æ£€æŸ¥å‡½æ•° =====
  function safeElementAccess(element, property, defaultValue = null) {
    try {
      if (!element || typeof element !== 'object') return defaultValue;
      return element[property] || defaultValue;
    } catch (e) {
      console.warn('å®‰å…¨è®¿é—®å…ƒç´ å±æ€§å¤±è´¥:', e);
      return defaultValue;
    }
  }

  function safeStyleAccess(element, property, value) {
    try {
      if (!element || !element.style) return false;
      element.style[property] = value;
      return true;
    } catch (e) {
      console.warn('å®‰å…¨è®¾ç½®æ ·å¼å¤±è´¥:', e);
      return false;
    }
  }

  // ===== ä¸»åˆå§‹åŒ–å‡½æ•° =====
  function initializeForumAssistant() {
    // é˜²æ­¢é‡å¤åˆå§‹åŒ–
    if (window.forumAssistantInitialized) {
      console.log('æ™ºèƒ½è®ºå›åŠ©æ‰‹å·²ç»åˆå§‹åŒ–ï¼Œè·³è¿‡é‡å¤åˆå§‹åŒ–');
      return;
    }

    try {
      console.log('å¼€å§‹åˆå§‹åŒ–æ™ºèƒ½è®ºå›åŠ©æ‰‹ Pro...');

      // æ£€æŸ¥å¿…è¦çš„API
      if (typeof GM_getValue === 'undefined') {
        console.warn('GM_getValue ä¸å¯ç”¨ï¼Œä½¿ç”¨ localStorage ä½œä¸ºå¤‡ç”¨');
        window.GM_getValue = (key, defaultValue) => {
          try {
            const value = localStorage.getItem('gm_' + key);
            return value !== null ? JSON.parse(value) : defaultValue;
          } catch (e) {
            return defaultValue;
          }
        };
        window.GM_setValue = (key, value) => {
          try {
            localStorage.setItem('gm_' + key, JSON.stringify(value));
          } catch (e) {
            console.error('å­˜å‚¨å¤±è´¥:', e);
          }
        };
        window.GM_deleteValue = (key) => {
          try {
            localStorage.removeItem('gm_' + key);
          } catch (e) {
            console.error('åˆ é™¤å¤±è´¥:', e);
          }
        };
        window.GM_listValues = () => {
          try {
            return Object.keys(localStorage).filter(key => key.startsWith('gm_')).map(key => key.substring(3));
          } catch (e) {
            return [];
          }
        };
      }

      // åˆ›å»ºä¸»ç¨‹åºå®ä¾‹
      forumAssistant = new ForumAssistant();

      // åˆ›å»ºæ¯æ—¥ä»»åŠ¡ç®¡ç†å™¨
      dailyTaskManager = new DailyTaskManager(
        forumAssistant.config,
        forumAssistant.logger,
        forumAssistant
      );

      // å¯åŠ¨æ¯æ—¥ä»»åŠ¡ç®¡ç†å™¨
      dailyTaskManager.start();

      // ç»‘å®šå…¨å±€äº‹ä»¶
      bindGlobalEvents();

      // å°†å®ä¾‹æš´éœ²åˆ°å…¨å±€ï¼Œä¾›æ§åˆ¶é¢æ¿è°ƒç”¨
      window.forumAssistant = forumAssistant;

      // æ ‡è®°åˆå§‹åŒ–å®Œæˆ
      window.forumAssistantInitialized = true;

      console.log('æ™ºèƒ½è®ºå›åŠ©æ‰‹ Pro åˆå§‹åŒ–å®Œæˆ');

    } catch (error) {
      console.error('æ™ºèƒ½è®ºå›åŠ©æ‰‹åˆå§‹åŒ–å¤±è´¥:', error);

      // æ˜¾ç¤ºé”™è¯¯é€šçŸ¥
      if (typeof GM_notification !== 'undefined') {
        GM_notification({
          text: `åˆå§‹åŒ–å¤±è´¥: ${error.message}`,
          title: 'æ™ºèƒ½è®ºå›åŠ©æ‰‹',
          timeout: 5000
        });
      } else {
        // å¤‡ç”¨é€šçŸ¥æ–¹å¼
        setTimeout(() => {
          alert(`æ™ºèƒ½è®ºå›åŠ©æ‰‹åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
        }, 1000);
      }
    }
  }

  // ===== ç»‘å®šå…¨å±€äº‹ä»¶ =====
  function bindGlobalEvents() {
    // é¡µé¢å¸è½½æ—¶ä¿å­˜æ•°æ®
    window.addEventListener('beforeunload', () => {
      if (forumAssistant && forumAssistant.isRunning) {
        forumAssistant.dataAnalyzer.endSession();
      }
    });

    // é¡µé¢å¯è§æ€§å˜åŒ–
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // é¡µé¢éšè—æ—¶æš‚åœæŸäº›åŠŸèƒ½
        if (forumAssistant) {
          forumAssistant.behaviorSimulator.stop();
        }
      } else {
        // é¡µé¢æ˜¾ç¤ºæ—¶æ¢å¤åŠŸèƒ½
        if (forumAssistant && forumAssistant.isRunning) {
          forumAssistant.behaviorSimulator.start();
        }
      }
    });

    // é”®ç›˜å¿«æ·é”®
    document.addEventListener('keydown', (e) => {
      // Ctrl+Shift+F: å¼€å¯/å…³é—­è®ºå›åŠ©æ‰‹
      if (e.ctrlKey && e.shiftKey && e.key === 'F') {
        e.preventDefault();
        if (forumAssistant) {
          if (forumAssistant.isRunning) {
            forumAssistant.stop();
          } else {
            forumAssistant.start();
          }
        }
      }

      // Ctrl+Shift+C: æ‰“å¼€é…ç½®é¢æ¿
      if (e.ctrlKey && e.shiftKey && e.key === 'C') {
        e.preventDefault();
        if (forumAssistant) {
          forumAssistant.configPanel.toggle();
        }
      }

      // Ctrl+Shift+S: æ˜¾ç¤º/éšè—ç»Ÿè®¡é¢æ¿
      if (e.ctrlKey && e.shiftKey && e.key === 'S') {
        e.preventDefault();
        if (forumAssistant) {
          forumAssistant.statsPanel.toggle();
        }
      }
    });

    // é”™è¯¯å¤„ç†
    window.addEventListener('error', (e) => {
      try {
        console.error('å…¨å±€é”™è¯¯æ•è·:', e.message, e.filename, e.lineno);
        if (forumAssistant && forumAssistant.logger) {
          forumAssistant.logger.log(`å…¨å±€é”™è¯¯: ${e.message} (${e.filename}:${e.lineno})`, 'error');
          if (forumAssistant.dataAnalyzer) {
            forumAssistant.dataAnalyzer.recordErrorEvent('global', e.message, e.filename);
          }
        }
      } catch (err) {
        console.error('é”™è¯¯å¤„ç†å™¨æœ¬èº«å‡ºé”™:', err);
      }
    });

    // æœªå¤„ç†çš„Promiseæ‹’ç»
    window.addEventListener('unhandledrejection', (e) => {
      try {
        console.error('æœªå¤„ç†çš„Promiseæ‹’ç»:', e.reason);
        if (forumAssistant && forumAssistant.logger) {
          forumAssistant.logger.log(`æœªå¤„ç†çš„Promiseæ‹’ç»: ${e.reason}`, 'error');
          if (forumAssistant.dataAnalyzer) {
            forumAssistant.dataAnalyzer.recordErrorEvent('promise', e.reason, 'unhandled_rejection');
          }
        }
        // é˜²æ­¢æ§åˆ¶å°é”™è¯¯
        e.preventDefault();
      } catch (err) {
        console.error('Promiseæ‹’ç»å¤„ç†å™¨å‡ºé”™:', err);
      }
    });
  }

  // ===== è„šæœ¬å¯åŠ¨ =====

  // å®‰å…¨å¯åŠ¨å‡½æ•°
  function safeInitialize() {
    try {
      // æ£€æŸ¥ç¯å¢ƒ
      if (typeof document === 'undefined') {
        console.error('document å¯¹è±¡ä¸å¯ç”¨');
        return;
      }

      // æ£€æŸ¥æ˜¯å¦åœ¨æ”¯æŒçš„é¡µé¢
      const supportedDomains = ['linux.do', 'meta.discourse.org', 'meta.appinn.net', 'community.openai.com', 'www.nodeloc.com', 'bbs.tampermonkey.net.cn', 'greasyfork.org'];
      const currentDomain = window.location.hostname;
      const isSupported = supportedDomains.some(domain => currentDomain.includes(domain));

      if (!isSupported) {
        console.log('å½“å‰åŸŸåä¸åœ¨æ”¯æŒåˆ—è¡¨ä¸­:', currentDomain);
        // ä»ç„¶å°è¯•åˆå§‹åŒ–ï¼Œå¯èƒ½æ˜¯æ–°çš„Discourseç«™ç‚¹
      }

      console.log('å¼€å§‹å®‰å…¨åˆå§‹åŒ–...');
      initializeForumAssistant();

    } catch (error) {
      console.error('å®‰å…¨åˆå§‹åŒ–å¤±è´¥:', error);
      // å»¶è¿Ÿé‡è¯•
      setTimeout(() => {
        console.log('å°è¯•é‡æ–°åˆå§‹åŒ–...');
        initializeForumAssistant();
      }, 3000);
    }
  }

  // å¤šç§å¯åŠ¨æ–¹å¼ç¡®ä¿è„šæœ¬èƒ½å¤Ÿè¿è¡Œ
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', safeInitialize);
  } else if (document.readyState === 'interactive' || document.readyState === 'complete') {
    // DOMå·²ç»åŠ è½½å®Œæˆï¼Œç«‹å³åˆå§‹åŒ–
    setTimeout(safeInitialize, 100);
  }

  // å¤‡ç”¨å¯åŠ¨æ–¹å¼1ï¼ˆwindow.loadäº‹ä»¶ï¼‰
  window.addEventListener('load', () => {
    if (!window.forumAssistantInitialized) {
      console.log('å¤‡ç”¨å¯åŠ¨æ–¹å¼1è§¦å‘ (window.load)');
      setTimeout(safeInitialize, 1000);
    }
  });

  // å¤‡ç”¨å¯åŠ¨æ–¹å¼2ï¼ˆå»¶è¿Ÿå¯åŠ¨ï¼‰
  setTimeout(() => {
    if (!window.forumAssistantInitialized) {
      console.log('å¤‡ç”¨å¯åŠ¨æ–¹å¼2è§¦å‘ (å»¶è¿Ÿå¯åŠ¨)');
      safeInitialize();
    }
  }, 5000);

  // å¤‡ç”¨å¯åŠ¨æ–¹å¼3ï¼ˆç”¨æˆ·äº¤äº’åå¯åŠ¨ï¼‰
  const interactionEvents = ['click', 'scroll', 'keydown'];
  const startOnInteraction = () => {
    if (!window.forumAssistantInitialized) {
      console.log('å¤‡ç”¨å¯åŠ¨æ–¹å¼3è§¦å‘ (ç”¨æˆ·äº¤äº’)');
      safeInitialize();
      // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
      interactionEvents.forEach(event => {
        document.removeEventListener(event, startOnInteraction);
      });
    }
  };

  interactionEvents.forEach(event => {
    document.addEventListener(event, startOnInteraction, { once: true, passive: true });
  });

})();
